[["index.html", "Análisis de datos con tablas y gráficos en SegmentaNet con R Capítulo 1 Prefacio 1.1 Requisitos 1.2 Estructura del documento", " Análisis de datos con tablas y gráficos en SegmentaNet con R Roberto Gil-Saura 2020-12-21 Capítulo 1 Prefacio 1.1 Requisitos El presente manual o guía de usuario focaliza e introduce al usuario de SegmentaNet en la creación de análisis utilizando scripting avanzado de tipo RMarkdown que permitan obtener cualquier tipo de tabla resumen de datos o cualquier análisis que pueda hacer utilizando código R (R Core Team 2020). Este manual ha sido redactado pensando en los usuarios de la plataforma SegmentaNet. Por tanto, se asume que el usuario estará registrado en alguna plataforma de SegmentaNet y se le supone conocimiento básico de cómo: Crear un proyecto Añadir un fuente de datos a un proyecto Crear un análisis scripting avanzado Te dejamos el acceso a los tutoriales genéricos y básicos, por si quieres visualizarlos antes de continuar. Si el usuario quisiera seguir esta documentación trabajando con RStudio, deberá obviar los comentarios acerca de SegmentaNet y utilizar sólo los scripts indicados creando archivos del tipo RMarkdown (Allaire et al. 2020) y estableciendo lo scripts como chunks o como r inline coding dentro del texto. 1.2 Estructura del documento En investigación de mercados, las tablas de contingencia o cruzadas probablemente sean el análisis de datos más predominante de todos los utilizados complementado por una potente visualización en forma de gráfico de esos datos. Se pretende dotar al usuario de SegmentaNet de las herramientas básicas que le permitan reproducir cualquier tipo de cuadro o tabla, de tipos marginal o cruzada, con medidas estadísticas, combinando estadísticos y frecuencias y/o porcentajes o realizar pruebas de significación, asi como la reproducción de los gráficos que se adaptarían a esas tablas. La estructura del manual se adapta por tanto a este objetivo, organizándose de la siguiente forma: una introducción al manual un capítulo que dedicamos a introducir al lector en el lenguaje R; no se pretende hacer un revisión exhaustiva del lenguaje, sino simplemente enumerar los términos y conceptos que serán necesarios para entender el funcionamiento de las tablas y el manejo y gestión de las mismas; un capítulo donde se introduce al usuario en la escritura de sencillas órdenes que como resultado obtendrán un cuadro o tabla; un capítulo dedicado a la creación de las tablas cruzadas; un capítulo dedicado a tablas más especiales, que denominaremos multi-dimensionales; un epígrafe dedicado a la generación de otras tablas auxiliares: cuadros, escalas, etc.; un epígrafe que describirá las pruebas básicas de significación que se utilizan en las tablas de contingencia; un capitulo dedicado a los gráficos; un epígrafe dedicado a operaciones con tablas, entre filas y/o columnas y a mejorar la visualización de las tablas y obtener gráficos a partir de estas operaciones especiales, ampliando el conjunto de paquetes a utilizar y combinando sus funcionalidades; por último, un capítulo más de lenguaje R para saber como se incluyen las condiciones para cualquier tipo de selección de datos. Para seguir este manual, como hemos comentado anteriormente, asumimos que el usuario conoce SegmentaNet y que ha constatado su necesidad de reproducir tipos de tabla que ha visto que son posibles de obtener en Quantum, Minitab, Systat, Star, SPSS o BarbWin y que SegmentaNet en su interfaz básica de usuario no alcanza a reproducir. Explicaremos los rudimentos básicos de trabajo en R, pero adecuados a su uso en SegmentaNet, con una primera introducción a SegmentaNet y cómo integramos R en su flujo de trabajo. Si no fuera así, recomendamos una primera lectura de la documentación online de SegmentaNet. Agradecemos expresamente a Gregory Demin (2020), desarrollador del paquete expss de R por su desinteresado trabajo en código abierto que permite reproducir e ir más allá de los cuadros resumen creados. Bibliografía "],["tse01.html", "Capítulo 2 Introducción 2.1 Preparar nuestro entorno 2.2 Mi primer análisis con scripting 2.3 Mi primera tabla con scripting 2.4 ¿Desde dónde creo mis scripts? 2.5 Conclusión", " Capítulo 2 Introducción  ¿por qué R en SegmentaNet? Parece algo contrario a lo que es la filosofía de trabajo de SegmentaNet, el dar la oportunidad de trabajar con programación (básica, pero al fin y al cabo programación) pero creemos poder dar una respuesta simple y clara, aunque sea formulando una nueva pregunta, ¿no es acaso necesario y nos viene muy bien el poder utilizar macros en software como Microsoft Office o sintaxis en SPSS? Pues esta es la respuesta y la razón de ofrecer en los planes 4GB y PREMIUM la posibilidad de que el usuario pueda utilizar código R (Team 2020) en sus análisis de datos, que le permitan ir mucho más allá de lo que ofrece SegmentaNet. Además, la elección de R no es casual. R se ha convertido en uno los de los estándares de facto de la industria del proceso, análisis y visualización de datos, dentro de ese nuevo ámbito que es al analítica o ciencia de datos, que está dando cabida a muchos profesionales de nueva creación y en la que nos estamos integrando muchos otros que provenimos de ámbitos diferentes. Es un estándar de la industria y está muy documentado en Internet, por lo que no debes tener muchos problemas para encontrar documentación al respecto. 2.1 Preparar nuestro entorno En nuestra infraestructura, R está integrado con SegmentaNet y no debes tener preocupación alguna acerca de su instalación o mantenimiento. Sólo debes indicar con qué paquetes quieres trabajar y listo. Si el paquete no está disponible en SegmentaNet, lo deberás comunicar en consultas@segmentanet.com para que sea instalado. Como usuario no puedes añadir paquetes. Pero vamos a trabajar con ello y verás que sencillo. Para comenzar, te aconsejamos crear un proyecto en el que añadiremos la fuente de datos que puedes descargar desde este enlace. Esta fuente de datos está en formato SPSS (sav) y se corresponde con la tercera oleada de un estudio del CIS de 2017, el barómetro sanitario. 2.1.1 Crear proyecto Así pues crea un proyecto desde el botón |+ Proyecto| del escritorio inicial de SegmentaNet e introduce estos datos (o los que quieras).. Crea proyecto -Paso 1- Tras acabar la inserción de esos datos, se indica que el proyecto no tiene fuentes de datos (conexión a algún banco de datos) Crea proyecto -Paso 2- 2.1.2 Crear fuente de datos Este es el momento de incluir la fuente de datos que indicábamos del estudio CIS SPSS. Descárgala y procede a su subida. Haz clic en la pestaña fuente de datos y también en |+ Nueva fuente de datos|  Fuente de datos -Paso 1- Sigue los pasos que aquí indicamos  Fuente de datos -Paso 2- |Siguiente| Fuente de datos -Paso 3- |Siguiente| Fuente de datos -Paso 4- |Siguiente| Fuente de datos -Paso 5- |Siguiente| Fuente de datos -Paso 6- Y ha finalizado la creación de la fuente de datos. En este momento ya tenemos creado el proyecto, subida nuestra fuente de datos y estamos en condiciones de comenzar a escribir scripts para tablas y/o gráficos. Si necesitas más ayuda en este aspecto, puedes consultar estos vídeos genéricos relacionados. Crear un proyecto Añadir un fuente de datos a un proyecto Crear un análisis -de tipo scripting avanzado- Como puedes observar, la fuente de datos tiene 2557 registros y tiene 190 campos. Si deseas ver el cuestionario que originalmente se utilizó para recoger los datos, lo puedes descargar aquí. En él puedes ver todo lo referente a como se ha realizado la entrevista. 2.2 Mi primer análisis con scripting Bien, pues vamos a ello. Vamos a comenzar por la base. Creamos un análisis en este proyecto, completamos su nombre y descripción, y elegimos el tipo scripting avanzado. 2.2.1 Crear análisis Para ello accedemos a la pestaña de análisis  Crear análisis -Paso 1-  y solicitamos la creación de un nuevo análisis Crear análisis -Paso 2-  donde iremos indicando los elementos del mismo necesarios. Es aquí donde deberemos seleccionar de entre la lista de análisis propuestos, la tipología que desemaos, que en nuestro caso es el Scripting avanzado (markdwon). Crear análisis -Paso 3- Al seleccionar el tipo de análisis indicado, se desencadena un proceso de asistentes que nos llevarán a poder determinar el tipo de análisis. La primera selección tras el tipo de análisis será cuál es nuestra fuente de datos, seleccionando la fuente que acabamos de subir a nuestro proyecto. Crear análisis -Paso 4- El siguiente paso consiste en elegir aquellos campos con los que se va a trabajar. Esto es muy importante. R trabaja con la información en la memoria del servidor, por lo que cuanto más optimicemos el tamaño del marco de datos (dataframe en el lenguaje R) todo fluirá más rápido. En el caso que nos ocupa, vamos a trabajar sólo con un campo, denominado PESO y que se ubica al final del listado. Crear análisis -Paso 5- Lo seleccionamos  Crear análisis -Paso 6- y lo pasamos a la caja de seleccionados de la derecha. Crear análisis -Paso 8- Finalizando este nuevo paso con |Siguiente|. En la siguiente pantalla, ya escribimos el script de R, que como puedes ver en línea 1 y 3 comienza y acaba con una simbología determinada. Estos son los caracteres indicadores de que todo lo que queda entre ```{r echo=TRUE} y ``` es scripting. A partir de ahora, nuestras instrucciones irán siempre entre estos símbolos de inicio y final. Nótese que se añade la instrucción echo=TRUE. Esta instrucción provocará que se imprima en el resultado los comandos del script, si en lugar de eso se escribe echo=FALSE, no se imprimiría ese código. El script debe escribirse así mean(data$PESO, na.rm=TRUE) ## [1] 0.9999273 Crear análisis -Paso 8- El script escrito contiene la información donde se indica: se calcula la media (mean); de una variable que está en el marco de datos denominado data); y que se llama PESO (data$PESO); no teniendo en cuenta los valores NA (nulos, no definidos, que no sean número: na.rm=TRUE) El resultado, ya puedes verlo, 0,9999273. Crear análisis -Paso 8- Terminamos con el análisis. Este aparece ahora en el listado de análisis realizados y podmos acceder a su posterior edición. Crear análisis -Paso 8- Vamos a realizar algunos cambios en nuestro script ¿Te parece que redondeemos esta cifra? Edita el análisis utilizando el icono de edición (lápiz) en la fila del gestor. Editar análisis -Paso 1- Se muestra la primera ventana del asistente  Editar análisis -Paso 2- Posteriormente, pinchamos en opciones y se mostrará nuevamente el script. Editar análisis -Paso 3- Ahora, edita el texto del script y déjalo como éste round(mean(data$PESO, na.rm=TRUE),2) ## [1] 1 Editar análisis -Paso 4- Como puedes observar, la edición ha consistido en añadir otra instrucción de R, el round, completando con el modificador ,2 que indica redondear a 2 decimales. El resultado es el siguiente  Editar análisis -Paso 5- Y ya podemos nuevamente abandonar nuestro script. Nuestro cambios quedan grabados. 2.2.2 Conclusión Así, hemos finalizado con nuestro primer script. Posiblemente pensarás que eso lo podías haber hecho también con un análisis descriptivo de SegmentaNet. Claro que sí, pero no nos vamos a detener aquí, vamos a seguir avanzando y aportando más. No volveremos a ser tan explicativos en este manual acerca de como crear y editar los scripts. La gestión de los scrips en SegmentaNet, la suponemos superada, por lo que ahora ya sólo mostraremos directamente el código de los scripts. El siguiente paso ya será utilizando el paquete de referencia Demin (2020). Este paquete está cargado por defecto si usas una fuente de datos alojada en SegmentaNet, pero si tratas de cargar una fuente externa (R te da esta posibilidad) lo deberás elegir como paquete a cargar desde el panel de Paquetes en la ventana de edición del script. 2.3 Mi primera tabla con scripting expss es un paquete desarrollado por Demin (2020) que calcula y muestra tablas con soporte para etiquetas de estilo SPSS, cabeceras múltiples y anidadas, pesos, variables de respuesta múltiple y pruebas de significación de tabla y celda. Ofrece facilidades para una salida formateada de tablas. Los métodos para variables etiquetadas agregan soporte de etiquetas de valor a las funciones de R base y a algunas funciones de otros paquetes. Es un paquete destinado a ayudar a las personas a cambiar el proceso de datos desde EXCEL y SPSS hasta R. Vamos a crear nuestra primera tabla con scripting avanzado en SegmentaNet, utilizando una instrucción muy básica de expss, que evolucionará en posteriores secciones. Aquí dejo algunos enlaces para que puedas leer acerca de este paquete y las posibilidades que te ofrece de modo combinado con SegmentaNet: manual PDF de EXPSS material de ayuda, ejemplos uso de etiquetas en R No vamos a repetir nuevamente todos los pasos de creación del análisis. Simplemente edita el análisis anterior la pestaña de Opciones escribe la siguiente sentencia a continuación de la anterior. Esta es la forma básica de pedir que se calcule la media de la variable PESO en expss Le indicamos: la instrucción de cálculo (calculate), el marco de datos (data), el cálculo a hacer cro_mean (equivalente a calcula la media (mean) en forma de tabla (crosstab). Mira su resultado: calculate(data, cro_mean(PESO)) #Total Ponderación 1 Verás algunos cambios respecto a la salida anterior, no hemos tenido que indicar cuántos decimales, ni que redondee, ni le hemos dicho que no tenga en cuenta los valores especiales o nulos y ha respondido de forma correcta. Ya vamos viendo que eso puede dar mucho juego, pero vamos a ir de forma ordenada y presentando poco a poco todos los tipos de tabla jugando con diferentes variables del banco de datos (¡¡¡ sí dataframe!!!) que hemos cargado. Comenzaremos con la creación de tablas unidimensionales o conocidas como marginales, para luego continuar con las tablas cruzadas, y entre medio, iremos incorporando medidas estadísticas. El capítulo 2, simplemente incorpora una serie de términos que manejamos en este manual. Da un vistazo, pero es posible que muchos de ellos ya sea habituales y conocidos por ti. Pasa pues la sección 3, donde comenzamos a trabajar los scripts. 2.4 ¿Desde dónde creo mis scripts? Hay diferentes lugares en SegmentaNet donde puedes utilizar scripting de código R. Hay otras partes de la plataforma que usan scripting de R, pero que no es editable por el usuario. Te explicamos brevemente la funcionalidad de las que sí puede el usuario trabajar. 2.4.1 Análisis En el menú de análisis hay dos tipos de análisis que utilizan scripting de R: scripting avanzado (consola) scripting avanzado (markdown) Cada uno de ellos presenta particularidades distintas. 2.4.1.1 Scripting avanzado (markdown) El scripting con markdown está pensado para generar páginas completas o documentos completos con texto, tablas, gráficos, etc. Se pueden utilizar paquetes como flexdashboard o generar salidas de tipo diapositiva utilizando las opciones de configuración que ofrece el paquete rmarkdown. No aseguramos una compatibilidad al 100%, pues eso sería imposible, pero gran parte de las características estarían funcionales. La idea es generar un documento HTML, de forma totalmente transparente para el usuario que se guarda en la base de datos y se presenta como resultado del análisis. Ese HTML puede contener texto, gráficos, tablas y cualquier elemento que se te ocurra. El código R se ubica en lo que se denomina chunks que luego veremos y se puede incluir también código R inline en el texto. 2.4.1.2 Scripting avanzado (consola) El scripting avanzado con consola está pensado para obtener tablas u otros objetos manipulados sobre los que realizar una publicación en modo tabla o en modo gráfico. Se da la oportunidad al usuario de elegir qué objeto y en qué formato se debe procesar. Tanto tabla como gráfico adquieren el aspecto estándar de SegmentaNet. 2.4.2 Procesos Desde procesos, el scripting avanzado (consola) se debería usar para crear una fuente de datos que pueda ser luego utilizada de forma estándar por el usuario de SegmentaNet. Por poner un ejemplo sencillo, imaginemos un archivo público que está en una URL, lo leemos, lo procesamos con scripts de R y obtenemos nuestra fuente de datos, que será subida a SegmentaNet de forma integrada en el proceso. 2.5 Conclusión En este documento, nos centraremos en trabajar con los análisis de tipo scripting avanzado markdown. Bibliografía "],["tse02.html", "Capítulo 3 Términos 3.1 Básicos de R y/o proceso de datos 3.2 Básicos de tabulación", " Capítulo 3 Términos En el presente capítulo mostramos un conjunto de términos que serán habitualmente utilizados en los sucesivos capítulos que se presentan en este documento. estos son los más relevantes y los hemos separado en dos grupos. un grupo hace referencia a términos básicos de R y otro grupo a términos básicos del manejo de tablas o del proceso de tabulación. Cada término tiene une breve reseña, y posteriormente algunos de ellos serán más tratados en sus respectivas funcionalidades. 3.1 Básicos de R y/o proceso de datos R es un entorno y lenguaje de programación con un enfoque al análisis estadístico. R nació como una implementación de software libre del lenguaje S, adicionado con soporte para alcance estático. Se trata de uno de los lenguajes de programación más utilizados en investigación científica, siendo además muy popular en los campos de aprendizaje automático (machine learning), minería de datos, investigación biomédica, bioinformática y matemáticas financieras. A esto contribuye la posibilidad de cargar diferentes bibliotecas o paquetes con funcionalidades de cálculo y graficación. R es parte del sistema GNU y se distribuye bajo la licencia GNU GPL. Está disponible para los sistemas operativos Windows, Macintosh, Unix y GNU/Linux. objeto, elemento creado desde comandos R y que puede ser reutilizado dentro de la programación del script. En este manual se usará como sinónimo de tabla en muchos casos, pues la mayoría de los objetos que crearemos serán tablas. dataframe, fichero de datos, banco de datos; término con el que se conoce en R a la estructura tabular (filas y columnas) de una matriz de datos, donde las columnas son variables y las filas son registros. variable, elemento de tipo vector que contiene los valores de una determinada observación, un valor en cada fila; debe entenderse en el contexto de la estructura tabular o dataframe. valores, cada una de las diferentes celdas que componen un dataframe. Una variable toma un valor en cada fila y se representa en la celda. medidas, valores de los que se pretende calcular estadísticos como la media, la desviación típica o la mediana entre otras. Suelen responder a escalas de tipo numérico (ordinal o métrico). dimensiones, valores de los que se pretende calcular frecuencias y/o porcentajes. factores, niveles, códigos, etiquetas de variable. NA, es como R representa los valores nulos o ausentes; SegmentaNet traduce todos los valores especiales (no contesta, no sabe, no definido o filtrado) a esta representación cuando se crea el dataframe de datos. valores perdidos, missing values, valores ausentes; tal como hemos indicado en el término NA, así es como R representa este tipo de valores. paquete, conjunto de funciones de las que el usuario hace uso para obtener un resultado en R; en nuestro caso particular principalmente usaremos el paquete EXPSS de R; 1. comando, instrucciones que se integran dentro de un chunk chunk, conjunto de comandos que se escriben entre los símbolos {r} y y que se ejecutan mostrando los resultados. 3.2 Básicos de tabulación En nuestro trabajo vamos a crear objetos de tipo tabla; una tabla es una estructura tabular, igual que un dataframe. De hecho, con nuestro trabajo utilizando el paquete EXPSS, vamos a generar tablas que serán dataframes de tipo (clase) etable. Al ser un dataframe, podremos operar entre filas, columnas y celdas de forma lógica o aritmética utilizando funciones y comandos de R. Dejamos este glosario de términos relacionados con las tablas que utilizaremos en esta guía. título (caption), texto que se publicará sobre la tabla; pie (footer), texto que se publicará bajo la tabla; fila, cada una de las líneas de información dentro de una tabla; se suele asimilar a un nivel (código) de una variable y/o a un resultados estadístico de una variable; columna, cada una de las variables que conforman el dataframe de una tabla (estructura tabular); en un cuadro o tabla de contingencia suele equivaler a un nivel de la variable que originalmente se diseñó para ser usada en columnas (si por ejemplo SEXO, una columna sería hombre y otra mujer); celda, cada una de las unidades de información del cuadro o tabla; row_labels, primera columna donde se escriben los textos de las filas y que sirven para identificar el contenido de las mismas; etiqueta de variable, texto extra identificativo de la variable usada en filas o columnas; etiqueta de valor, texto del código identificativo de la variable usada; estadístico, medida calculada; frecuencia, tipo específico de medida calculada que significa número de veces en términos absolutos; porcentaje, tipo específico de medida calculada que significa número de veces en términos relativos; |, símbolo denominado pipe que en el paquete expss se utilizará para separar conjuntos de texto en una celda (o columna o fila); significación, prueba estadística de contraste. "],["tse03.html", "Capítulo 4 Tablas marginales 4.1 Frecuencias 4.2 Estadísticos 4.3 Conclusión", " Capítulo 4 Tablas marginales Vamos a comenzar con un conjunto de tablas muy sencillas. En ellas representaremos los valores obtenidos del análisis de un campo extraído de nuestra fuente de datos de referencia, la tercera oleada del Barómetro Sanitario en España de 2017 del realizado y publicado por el CIS. Por ahora, trabajaremos sólo con la variable denominada P31 (sexo del entrevistado), variable medida en escala nominal, cuyas etiquetas (valores) son hombre (1) y mujer (2) y con la variable P3, escala de satisfacción (1-10) con el funcionamiento del sistema sanitario español, medida de 1 a 10. En nuestra fuente de datos tenemos 2557 casos (entrevistas realizadas). Para ello utilizaremos un script, es decir una pocas líneas de código que mostraremos en este mismo documento con un fondo gris. Lo que quede fuera de ese trozo del documento, será como este texto que estoy escribiendo. Este texto que además, puede ser formateado como si de un HTML se tratará, es lo que llamamos un archivo markdown, y como es de R, pues lo llamamos rmarkdown. Verás que también este documento tiene títulos, que se obtienen anteponiendo el símbolo # desde 1 vez hasta 6 veces y que se corresponde con las etiquetas de título de HTML. Inicialmente, comentaremos las líneas del script utilizando el también el mismo símbolo, pero no al inicio de la línea sino al final Lo que quede por detrás de él, se considera un comentario. 4.1 Frecuencias Este conjunto de tablas sólo trabajará que con el estadístico de cálculo de frecuencias. Comenzaremos con variables de respuesta simple, para luego avanzar a las variables de respuesta múltiple y al uso de medidas estadísticas básicas (suma, media, mediana, máximo, mínimo, etc.). 4.1.1 Variables de respuesta simple 4.1.1.1 Cálculo de frecuencias (estilo SPSS) Utilizaremos en estos ejemplos de forma inicial un campo del marco de datos, P31, de respuesta simple. La primera tabla que haremos responde a un recuento de frecuencias, y es muy usada para el análisis univariante de una campo. Este comando muestra una tabla básica utilizando la función fre() que copia la salida del SPSS. Nótese que la columna de porcentaje válido y porcentaje es igual ante la inexistencia de NA (valores perdidos). fre(data$P31) Sexo de la persona entrevistada Count Valid percent Percent Responses, % Cumulative responses, % Hombre 1256 49.1 49.1 49.1 49.1 Mujer 1301 50.9 50.9 50.9 100.0 #Total 2557 100 100 100 &lt;NA&gt; 0 0.0 Alternativamente se puede presentar la forma que trabajaremos a lo largo de este curso, esta forma es la denominada script encadenado, donde definimos el marco de datos al inicio, y encadenamos instrucciones con el símbolo %&gt;% que irían línea a línea sucesivamente para una mejor lectura y comprensión del texto escrito; podrían perfectamente ir en una línea. Nótese que la tabla sale igual con las dos formas, pero mientras que en el primer caso se usa la nomenclatura estándar de R, y el campo se llama data$P31, es decir nombre del marco de datos en R (data) el símbolo del $ que separa y nombre del campo en el marco de datos P31 en la segunda al definir de inicio que se utilizará dataya se usa el nombre P31directamente, aunque debamos dar la orden de cálculo con el comando calculate(). data %&gt;% calculate(fre(P31)) Sexo de la persona entrevistada Count Valid percent Percent Responses, % Cumulative responses, % Hombre 1256 49.1 49.1 49.1 49.1 Mujer 1301 50.9 50.9 50.9 100.0 #Total 2557 100 100 100 &lt;NA&gt; 0 0.0 Veamos ahora cómo solicitaremos tablas de frecuencias, porcentajes y estadísticos simples con SegmentaNet y R. 4.1.1.2 Tablas de frecuencias (absolutos) La segunda tabla que vamos a hacer, ya responde a la típica presentación de una tabla de contingencia, sólo que en este casos vamos a mostrar sólo un campo y por tanto no va a haber cruce de variables. En el paquete expss, para construir un cuadro deberemos indicar al menos: un marco de datos (dataframe en nomenclatura R) referenciar la variable sobre la que se deben calcular el estadístico seleccionado (frecuencia -casos-, media, mediana, máximo, mínimo) una orden de impresión de tabla Estos elementos básicos pueden completarse con campos de columnas, campos de filas, pruebas de significación, etc. Iremos desarrollando estos conceptos a lo largo de este documento. ¡Vamos a por el cuadro! La que ahora entregamos, es la estructura básica de un script de R con el paquete expss. A lo largo del documento veremos cómo ir introduciendo mínimas variaciones a esta estructura que te permitirán descubrir un sinnúmero de posibilidades que ofrece este paquete de R. Por ejemplo, podemos modificar la etiqueta de TOTAL o indicar donde debe situarse la fila que contiene el cálculo TOTAL. Todas estas posibilidades las puedes conocer en la documentación original del package, aunque en este manual trataremos de ir desgranado las más relevantes para nuestro objetivo. Inicialmente iremos añadiendo tras el operador %&gt;% comentarios precedidos por el simbolo #. Estos comentarios irán desapareciendo a medida que avancemos en el manual, y sólo se recurrirá a ellos cuando se aporte alguna nueva funcionalidad. Para este primer script, indicaremos que usamos la fuente de datos (dataframe) cargado en el análisis. En SegmentaNet siempre se llama data a este dataframe cargada en el análisis. Si estamos en RSTudio, el dataframe tendrá el nombre que le hayas indicado en la carga. Redactamos pues nuestro script, donde identificamos el dataframe, el campo P31 del cual vamos a calcular el número de casos: data %&gt;% tab_cells(P31) %&gt;% tab_stat_cases() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre 1256 Mujer 1301 #Total cases 2557 Realicemos ahora una pequeña pero importante variación en el cálculo del estadístico casos -frecuencias- y utilicemos la posibilidad de ubicar donde queramos el total de casos, así como su etiqueta. Ello lo hacemos con total_row_position = \"above\", label = \"Casos\" aplicado a la función tab_stat_cases(). data %&gt;% tab_cells(P31) %&gt;% tab_stat_cases(total_row_position = &quot;above&quot;, label = &quot;Casos&quot;) %&gt;% tab_pivot() #Total Sexo de la persona entrevistada #Total cases Casos 2557 Hombre Casos 1256 Mujer Casos 1301 4.1.1.3 Tablas de frecuencias relativas Si en lugar de obtener casos (valores absolutos) queremos sacar valores porcentuales, el cambio es mínimo. Usaremos el comando tab_stat_cpct()para indicarlo. data %&gt;% tab_cells(P31) %&gt;% tab_stat_cpct(total_row_position = &quot;above&quot;, label = &quot;% casos&quot;) %&gt;% tab_pivot() #Total Sexo de la persona entrevistada #Total cases % casos 2557 Hombre % casos 49.1 Mujer % casos 50.9 4.1.1.4 Tablas de absolutos y realativos (juntos) Cuando deseamos hacer combinaciones de frecuencias y porcentajes, la filosofía de trabajo es muy parecida. En nuestro caso vamos a hacer algo muy típico. Aunque creo que resulta más sencillo leer cada estadístico en su tabla, hay ocasiones en las que la comparativa es muy necesaria y por tanto es ncesario unir los estadísticos en la misma tabla. Nótese la diferencia con el siguiente cuadro data %&gt;% tab_cells(P31) %&gt;% tab_stat_cases(total_row_position = &quot;above&quot;, label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_columns&quot;) #Total Casos % casos Sexo de la persona entrevistada #Total cases 2557 2557 Hombre 1256 49.1 Mujer 1301 50.9 Nótese el efecto introducido por el modificador de posición del cálculo. También  data %&gt;% tab_cells(P31) %&gt;% tab_stat_cases(total_row_position = &quot;above&quot;, label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_rows&quot;) #Total Sexo de la persona entrevistada #Total cases Casos 2557 Hombre Casos 1256.0 Mujer Casos 1301.0 Hombre % casos 49.1 Mujer % casos 50.9 #Total cases % casos 2557 O también  data %&gt;% tab_cells(P31) %&gt;% tab_stat_cases(total_row_position = &quot;below&quot;, label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_columns&quot;) #Total Casos % casos Sexo de la persona entrevistada Hombre 1256 49.1 Mujer 1301 50.9 #Total cases 2557 2557 4.1.2 Variable de respuesta múltiple Vamos a trabajar ahora con variables multi-respuesta. SegmentaNet (así lo hace también SPSS) divide la variable múltiple en tantas variables simples (o dicotómicas binarias) como requiera para poder representar la multi-respuesta. Por ejmplo, si tenemos una variable múltiple denominada P01, y el máximo número de respuestas (menciones) en el banco de datos es 3, al crear el dataframe se crean las variables P01_1, P01_2 y P01_3; es con estas variables con las que trabajamos. Cada una de estas variables puede tomar cualquiera de los valores codificados. Para expss en SegmentaNet, la forma de indicar que un conjunto de campos forman una multi-respuesta es muy simple anteponer mrset_f() al nombre del campo que vamos a usar. Debemos tener la precaución de que no haya variables en el banco de datos que comiencen por la misma raíz. Así, el campo de ejemplo sería mrset_f(P01_)y con eso procesaría las tres variables de forma conjunta. Alternativamente, podríamos usar también: mrset(P01_1 %to% P01_3) o también, mrset(P01_1,P01_2,P01_3) Cualquiera de ellas sería también válida, pero nótese que en estas últimas listadas, es necesario saber donde empieza y acaba la múltiple y esto puede variar sobretodo si creamos los scripts antes de acabar el campo. Al acabar el campo, pudiera haber algún nuevo caso que tuviera más menciones que 3 y por tanto existirían también _4, _5 o, _n. Como hemos indicado, no olvides que existe otra forma de trabajar las múltiples, utilizando variables dicotómicas o binarias (así es como están en nuestro banco de datos del CIS). En este caso, serviría todo lo afirmado anterioremnte, pero en lugar de mrset_f(), usaríamos mdset_f(). 4.1.2.1 Tablas de frecuencias absolutas Usaremos el campo P18C para procesar su información, que se localiza en el banco de datos desde P18C01 hasta P18C08. data %&gt;% tab_cells(mdset_f(P18C)) %&gt;% tab_stat_cases(total_row_position=&quot;above&quot;, label=&quot;Casos&quot;) %&gt;% tab_pivot(stat_position=&quot;inside_columns&quot;) #Total Casos #Total cases 198 La tarjeta sanitaria no funcionaba 33 El ordenador de la farmacia no funcionaba 23 Estaba fuera de plazo (era demasiado pronto o demasiado tarde) 75 No aparecían los medicamentos recetados 57 No pudo retirarlos en una comunidad autónoma distinta a la suya 17 Otro tipo de problema 48 No recuerda N.C. 3 4.1.2.2 Tablas de frecuencias relativas También se pueden, como es obvio, obtener porcentajes en las tablas marginales múltiples. A diferencia de cuando la variables es simple que todos los porcentajes suman 100, en las variables múltiples cada alternativa tiene un rango de 0 a 100, desde no ser elegida una opción en ningún registro del dataframe, hasta ser elegida por todos los registros. Usaremos nuevamente el campo P18C para procesar su información, que se localiza en el banco de datos desde P18C01 hasta P18C08. data %&gt;% tab_cells(mdset_f(P18C)) %&gt;% tab_stat_cpct(total_row_position=&quot;above&quot;, label=&quot;% casos&quot;) %&gt;% tab_pivot(stat_position=&quot;inside_columns&quot;) #Total % casos #Total cases 198 La tarjeta sanitaria no funcionaba 16.7 El ordenador de la farmacia no funcionaba 11.6 Estaba fuera de plazo (era demasiado pronto o demasiado tarde) 37.9 No aparecían los medicamentos recetados 28.8 No pudo retirarlos en una comunidad autónoma distinta a la suya 8.6 Otro tipo de problema 24.2 No recuerda N.C. 1.5 Pero vamos a introducir una njueva variación. En una múltiple, también pueden calcularse los resultados en lo que se llama base respuestas, donde sí suman 100% los porcentajes nuevamente, pero recuerda que el porcentaje hace referencia a las respuestas, no a los individuos. En este caso el script modifica el estadístico solicitado. data %&gt;% tab_cells(mdset_f(P18C)) %&gt;% tab_stat_cpct_responses(total_row_position=&quot;above&quot;, label=&quot;% casos&quot;) %&gt;% tab_pivot(stat_position=&quot;inside_columns&quot;) #Total % casos #Total responses 256 La tarjeta sanitaria no funcionaba 12.9 El ordenador de la farmacia no funcionaba 9.0 Estaba fuera de plazo (era demasiado pronto o demasiado tarde) 29.3 No aparecían los medicamentos recetados 22.3 No pudo retirarlos en una comunidad autónoma distinta a la suya 6.6 Otro tipo de problema 18.8 No recuerda N.C. 1.2 4.1.3 Tablas combinadas Con las múltiples también funciona el posicionamiento del estadístico casos -frecuencias- cuando combinamos los mismos (frecuencia y porcentaje) y podemos realizar las mismas variantes que antes. Ubicar los cálculos dentro de las columnas  data %&gt;% tab_cells(mdset_f(P18C)) %&gt;% # o tab_cells(mdset(P18C01 %to% P18C08)) tab_stat_cases(label =&quot;Casos&quot;) %&gt;% tab_stat_cpct(label=&quot;% casos&quot;) %&gt;% tab_stat_cpct_responses(label=&quot;% respuestas&quot;) %&gt;% tab_pivot(stat_position=&quot;inside_columns&quot;) #Total Casos % casos % respuestas La tarjeta sanitaria no funcionaba 33 16.7 12.9 El ordenador de la farmacia no funcionaba 23 11.6 9.0 Estaba fuera de plazo (era demasiado pronto o demasiado tarde) 75 37.9 29.3 No aparecían los medicamentos recetados 57 28.8 22.3 No pudo retirarlos en una comunidad autónoma distinta a la suya 17 8.6 6.6 Otro tipo de problema 48 24.2 18.8 No recuerda N.C. 3 1.5 1.2 #Total responses 256 #Total cases 198 198 Préstese atención a las dos líneas de #Total, dado que las bases son diferentes (número de individuos y número de respuestas). Podemos ubicar los cálculos dentro de las filas  data %&gt;% tab_cells(mdset_f(P18C)) %&gt;% # o tab_cells(mdset(P18C01 %to% P18C08)) tab_stat_cases(label =&quot;Casos&quot;) %&gt;% tab_stat_cpct(label=&quot;% casos&quot;) %&gt;% tab_stat_cpct_responses(label=&quot;% respuestas&quot;) %&gt;% tab_pivot(stat_position=&quot;inside_rows&quot;) #Total La tarjeta sanitaria no funcionaba Casos 33.0 % casos 16.7 % respuestas 12.9 El ordenador de la farmacia no funcionaba Casos 23.0 % casos 11.6 % respuestas 9.0 Estaba fuera de plazo (era demasiado pronto o demasiado tarde) Casos 75.0 % casos 37.9 % respuestas 29.3 No aparecían los medicamentos recetados Casos 57.0 % casos 28.8 % respuestas 22.3 No pudo retirarlos en una comunidad autónoma distinta a la suya Casos 17.0 % casos 8.6 % respuestas 6.6 Otro tipo de problema Casos 48.0 % casos 24.2 % respuestas 18.8 No recuerda Casos % casos % respuestas N.C. Casos 3.0 % casos 1.5 % respuestas 1.2 #Total cases Casos 198 % casos 198 #Total responses % respuestas 256 Podemos ubicar los cálculos fuera de las columnas (igual a la anterior inside... porque no hay campo de columna)  data %&gt;% tab_cells(mdset_f(P18C)) %&gt;% # o tab_cells(mdset(P18C01 %to% P18C08)) tab_stat_cases(label =&quot;Casos&quot;) %&gt;% tab_stat_cpct(label=&quot;% casos&quot;) %&gt;% tab_stat_cpct_responses(label=&quot;% respuestas&quot;) %&gt;% tab_pivot(stat_position=&quot;outside_columns&quot;) #Total Casos % casos % respuestas La tarjeta sanitaria no funcionaba 33 16.7 12.9 El ordenador de la farmacia no funcionaba 23 11.6 9.0 Estaba fuera de plazo (era demasiado pronto o demasiado tarde) 75 37.9 29.3 No aparecían los medicamentos recetados 57 28.8 22.3 No pudo retirarlos en una comunidad autónoma distinta a la suya 17 8.6 6.6 Otro tipo de problema 48 24.2 18.8 No recuerda N.C. 3 1.5 1.2 #Total responses 256 #Total cases 198 198 Podemos ubicar los cálculos fuera de las filas  nótese que la agrupación es diferente a la anterior con inside_rows data %&gt;% tab_cells(mdset_f(P18C)) %&gt;% # o tab_cells(mdset(P18C01 %to% P18C08)) tab_stat_cases(label =&quot;Casos&quot;) %&gt;% tab_stat_cpct(label=&quot;% casos&quot;) %&gt;% tab_stat_cpct_responses(label=&quot;% respuestas&quot;) %&gt;% tab_pivot(stat_position=&quot;outside_rows&quot;) #Total La tarjeta sanitaria no funcionaba Casos 33.0 El ordenador de la farmacia no funcionaba Casos 23.0 Estaba fuera de plazo (era demasiado pronto o demasiado tarde) Casos 75.0 No aparecían los medicamentos recetados Casos 57.0 No pudo retirarlos en una comunidad autónoma distinta a la suya Casos 17.0 Otro tipo de problema Casos 48.0 No recuerda Casos N.C. Casos 3.0 #Total cases Casos 198 La tarjeta sanitaria no funcionaba % casos 16.7 El ordenador de la farmacia no funcionaba % casos 11.6 Estaba fuera de plazo (era demasiado pronto o demasiado tarde) % casos 37.9 No aparecían los medicamentos recetados % casos 28.8 No pudo retirarlos en una comunidad autónoma distinta a la suya % casos 8.6 Otro tipo de problema % casos 24.2 No recuerda % casos N.C. % casos 1.5 #Total cases % casos 198 La tarjeta sanitaria no funcionaba % respuestas 12.9 El ordenador de la farmacia no funcionaba % respuestas 9.0 Estaba fuera de plazo (era demasiado pronto o demasiado tarde) % respuestas 29.3 No aparecían los medicamentos recetados % respuestas 22.3 No pudo retirarlos en una comunidad autónoma distinta a la suya % respuestas 6.6 Otro tipo de problema % respuestas 18.8 No recuerda % respuestas N.C. % respuestas 1.2 #Total responses % respuestas 256 4.2 Estadísticos Hasta ahora hemos trabajado sólo con casos, pero ya hemos anticipado que al igual que con los recuentos de casos o frecuencias se puede trabajar con otros estadísticos como la suma, máximo, mínimo, media, mediana, error estándar y desviación típica. Vamos a ir viendo cómo se desarrollan estos cuadros. 4.2.1 Estadísticos básicos Recordemos que hasta ahora no hemos cruzado la información, solo estamos trabajando con lo que se denomina medidas marginales.Nuestro primer ejemplo es un caso típico, donde queremos obtener la media (tab_stat_mean), la desviación típica (tab_stat_sd()) y la base de cálculo, es decir el número de casos con valor (tab_stat_valid_n()) para el cálculo. Así, siguiendo la misma estructra de las tablas anteriores, redactamos el siguiente script: data %&gt;% tab_cells(P3) %&gt;% tab_stat_mean() %&gt;% tab_stat_sd() %&gt;% tab_stat_valid_n() %&gt;% tab_pivot() #Total Escala de satisfacción (1-10) con el funcionamiento del sistema sanitario español Mean 7.3 Std. dev. 7.2 Valid N 2557.0 No, no tienes por qué ver los nombres de los estadísticos en lengua inglesa. También aquí podemos jugar con la etiqueta (label). data %&gt;% tab_cells(P3) %&gt;% tab_stat_mean(label = &#39;media&#39;) %&gt;% tab_stat_sd(label = &#39;desviación&#39;) %&gt;% tab_stat_valid_n(label = &#39;casos&#39;) %&gt;% tab_pivot() #Total Escala de satisfacción (1-10) con el funcionamiento del sistema sanitario español media 7.3 desviación 7.2 casos 2557.0 Hagamos una nueva tabla con una pequeña variación, ahora vamos a poner los estadísticos en columnas. data%&gt;% tab_cells(P3) %&gt;% tab_stat_mean(label = &#39;media&#39;) %&gt;% tab_stat_sd(label = &#39;desviación&#39;) %&gt;% tab_stat_valid_n(label = &#39;casos&#39;) %&gt;% tab_pivot(stat_position = &quot;inside_columns&quot;) #Total media desviación casos Escala de satisfacción (1-10) con el funcionamiento del sistema sanitario español 7.3 7.2 2557 expss tiene además la posibilidad de obtener estos tres cálculos, bastante habituales por cierto, con un solo comando: tab_stat_mean_sd_n() pudiendo añadir además etiquetas separadas. data %&gt;% tab_cells(P3) %&gt;% tab_stat_mean_sd_n(labels = c(&quot;media&quot;, &quot;desviación&quot;, &quot;casos&quot;)) %&gt;% tab_pivot() #Total Escala de satisfacción (1-10) con el funcionamiento del sistema sanitario español media 7.3 desviación 7.2 casos 2557.0 4.2.2 Otros estadísticos Además de los estadísticos más básicos, otros que podemos añadir son el máximo, el mínimo, la mediana, el error estándar y la suma. Los unimos todos. data %&gt;% tab_cells(P3) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_stat_max(label = &quot;Máximo&quot;) %&gt;% tab_stat_min(label = &quot;Mínimo&quot;) %&gt;% tab_stat_median(label = &quot;Mediana&quot;) %&gt;% tab_stat_se(label = &quot;Error estándar&quot;) %&gt;% tab_stat_sum(label = &quot;Suma&quot;) %&gt;% tab_pivot() #Total Escala de satisfacción (1-10) con el funcionamiento del sistema sanitario español Media 7.3 Desviación 7.2 Máximo 99.0 Mínimo 1.0 Mediana 7.0 Error estándar 0.1 Suma 18789.0 Nótese que no se han definido ni filas, ni columnas. Es el modificador de la posición de los estadísticos (stat_position) el que habilita la posición en una fila. Del mismo modo, estos estadísticos pueden ubicarse en las columnas. data %&gt;% tab_cells(P3) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_stat_max(label = &quot;Máximo&quot;) %&gt;% tab_stat_min(label = &quot;Mínimo&quot;) %&gt;% tab_stat_median(label = &quot;Mediana&quot;) %&gt;% tab_stat_se(label = &quot;Error estándar&quot;) %&gt;% tab_stat_sum(label = &quot;Suma&quot;) %&gt;% tab_stat_cases(label = &quot;casos&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_rows&quot;) #Total Escala de satisfacción (1-10) con el funcionamiento del sistema sanitario español Media 7.3 Desviación 7.2 Máximo 99.0 Mínimo 1.0 Mediana 7.0 Error estándar 0.1 Suma 18789.0 1 Muy insatisfecho/a casos 40.0 2 casos 35.0 3 casos 75.0 4 casos 111.0 5 casos 295.0 6 casos 397.0 7 casos 584.0 8 casos 623.0 9 casos 210.0 10 Muy satisfecho/a casos 172.0 N.S. casos 14.0 N.C. casos 1.0 #Total cases casos 2557 Hagamos finalmente una leve variación. Nótese que al utilizar '|'en la etiqueta del estadístico casos, hemos eliminado la columna intermedia y aparace todo como más compacto. Este será un recurso que utilizaremos en muchas ocasiones. data %&gt;% tab_cells(P3) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_stat_max(label = &quot;Máximo&quot;) %&gt;% tab_stat_min(label = &quot;Mínimo&quot;) %&gt;% tab_stat_median(label = &quot;Mediana&quot;) %&gt;% tab_stat_se(label = &quot;Error estándar&quot;) %&gt;% tab_stat_sum(label = &quot;Suma&quot;) %&gt;% tab_stat_cases(label = &quot;|&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_rows&quot;) #Total Escala de satisfacción (1-10) con el funcionamiento del sistema sanitario español Media 7.3 Desviación 7.2 Máximo 99.0 Mínimo 1.0 Mediana 7.0 Error estándar 0.1 Suma 18789.0 1 Muy insatisfecho/a 40.0 2 35.0 3 75.0 4 111.0 5 295.0 6 397.0 7 584.0 8 623.0 9 210.0 10 Muy satisfecho/a 172.0 N.S. 14.0 N.C. 1.0 #Total cases 2557 4.3 Conclusión Creo que esta primera muestra de cómo procesar nuestra tabla de una única variable, es más que suficiente para colmar las expectativas más exigentes. Para aquellos que conozcan un poco más el funcionamiento de R, indicar que cada una de estas tablas, se puede almacenar como objeto sobre el que se puede trabajar. Este objeto es del tipo etable pero en el fondo es un objeto de tipo dataframe que por tanto puedes ser trabajado con comandos R estándar. Es de esta posibilidad de ser un dataframe de donde deriva su capacidad de integración con otros paquetes como por ejemplo highcharter Kunst (2020) que será uno de nuestros paquetes de referencia para gráficos y que también lo es para SegmentaNet que utiliza esta librería de gráficos como estándar. Para una presentación completa, véase la sección 9 para una presentación de gráficos a partir de dataframe o de crosstab. Bibliografía "],["tse04.html", "Capítulo 5 Tablas cruzadas 5.1 Básica con variables simples 5.2 Básica con múltiples 5.3 Básica con estadísticos", " Capítulo 5 Tablas cruzadas A diferencia de lo visto en el anterior capítulo, en este epígrafe analizaremos como obtener cuadros resumen en los que existen variables en la cabecera, que determinan grupos de análisis y existen variables en las filas, de las cuáles queremos conocer como se distribuyen sus alternativas de respuesta entre los diferentes perfiles o grupos que determinan las variables de columna. Al igual que sucedió con las tablas marginales, mostraremos poco a poco como trabajar con variables de respuesta simple, múltiple o con medidas estadísticas. Vamos a utilizar otros campos que se localizan en la base de datos del CIS (P3, P21A01, P21A02, P21A03, P31, P33), así que si estás trabajando en SegmentaNet, recuerda elegirlos en el paso campos cuando crees el análisis correspondiente. 5.1 Básica con variables simples Las tablas que vamos a hacer a continuación, siempre son tablas en las que intervienen al menos dos variables. Una de las variables irá a columnas y la otra variable irá a filas. De ellas se calcularán las frecuencias absolutas o relativas y/o los estadísticos. Vamos a empezar sólo con el estadístico frecuencias, y posteriormente ya pasaremos a estadísticos como la media, suma, etc 5.1.1 De frecuencias, variable simple y sólo absolutos data %&gt;% tab_cells(P33) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(total_row_position = &quot;above&quot;, total_label = &quot;Total&quot;) %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Estado civil de la persona entrevistada #Total 2557 1256 1301 Casado/a 1388 677 711 Soltero/a 817 455 362 Viudo/a 190 41 149 Separado/a 57 24 33 Divorciado/a 97 55 42 N.C. 8 4 4 5.1.2 De frecuencias, variable simple, con porcentajes de columna Al igual que hicimos con las tablas marginales vamos a repetir esta tabla, pero en porcentaje de columna (vertical). data %&gt;% tab_cells(P33) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cpct(total_row_position = &quot;above&quot;, total_label = &quot;Total&quot;) %&gt;% # aquí señalo los porcentajes de columna tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Estado civil de la persona entrevistada #Total 2557 1256 1301 Casado/a 54.3 53.9 54.7 Soltero/a 32.0 36.2 27.8 Viudo/a 7.4 3.3 11.5 Separado/a 2.2 1.9 2.5 Divorciado/a 3.8 4.4 3.2 N.C. 0.3 0.3 0.3 5.1.3 De frecuencias, variable simple, con porcentajes de fila Al igual que hicimos con las tablas marginales vamos a repetir esta tabla, pero en porcentaje de fila (horizontal). data %&gt;% tab_cells(P33) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_rpct(total_row_position = &quot;above&quot;, total_label = &quot;Total&quot;) %&gt;% # aquí señalo los porcentajes de fila tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Estado civil de la persona entrevistada #Total 2557 1256 1301 Casado/a 100 48.8 51.2 Soltero/a 100 55.7 44.3 Viudo/a 100 21.6 78.4 Separado/a 100 42.1 57.9 Divorciado/a 100 56.7 43.3 N.C. 100 50.0 50.0 5.1.4 De frecuencias, variable simple, con porcentajes total muestra Al igual que hicimos con las tablas marginales vamos a repetir esta tabla, pero en porcentaje sobre el total de la muestra. data %&gt;% tab_cells(P33) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_tpct(total_row_position = &quot;above&quot;, total_label = &quot;Total&quot;) %&gt;% # aquí señalo los porcentajes total muestra tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Estado civil de la persona entrevistada #Total 2557 1256 1301 Casado/a 54.3 26.5 27.8 Soltero/a 32.0 17.8 14.2 Viudo/a 7.4 1.6 5.8 Separado/a 2.2 0.9 1.3 Divorciado/a 3.8 2.2 1.6 N.C. 0.3 0.2 0.2 5.1.5 Combinaciones de los anteriores Vamos ahora a hacer combinaciones entre ellos. Advierto que cada vez se dificulta más la tabla en su lectura. Como dije inicialmente, me decanto más por tablas sencillas y con un sólo dato. data %&gt;% tab_cells(P33) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_columns&quot;) #Total Sexo de la persona entrevistada Casos % casos Hombre Mujer Casos % casos Casos % casos Estado civil de la persona entrevistada Casado/a 1388 54.3 677 53.9 711 54.7 Soltero/a 817 32.0 455 36.2 362 27.8 Viudo/a 190 7.4 41 3.3 149 11.5 Separado/a 57 2.2 24 1.9 33 2.5 Divorciado/a 97 3.8 55 4.4 42 3.2 N.C. 8 0.3 4 0.3 4 0.3 #Total cases 2557 2557 1256 1256 1301 1301 Y la misma tabla pero con los estadísticos en las filas combinando frecuencia y porcentaje data %&gt;% tab_cells(P33) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_columns&quot;) #Total Sexo de la persona entrevistada #Total Sexo de la persona entrevistada Casos Hombre Mujer % casos Hombre Mujer Casos Casos % casos % casos Estado civil de la persona entrevistada Casado/a 1388 677 711 54.3 53.9 54.7 Soltero/a 817 455 362 32.0 36.2 27.8 Viudo/a 190 41 149 7.4 3.3 11.5 Separado/a 57 24 33 2.2 1.9 2.5 Divorciado/a 97 55 42 3.8 4.4 3.2 N.C. 8 4 4 0.3 0.3 0.3 #Total cases 2557 1256 1301 2557 1256 1301 Y la misma tabla pero con los estadísticos en las filas combinando frecuencia y porcentaje data %&gt;% tab_cells(P33) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_rows&quot;) #Total Sexo de la persona entrevistada Hombre Mujer Estado civil de la persona entrevistada Casado/a Casos 1388.0 677.0 711.0 % casos 54.3 53.9 54.7 Soltero/a Casos 817.0 455.0 362.0 % casos 32.0 36.2 27.8 Viudo/a Casos 190.0 41.0 149.0 % casos 7.4 3.3 11.5 Separado/a Casos 57.0 24.0 33.0 % casos 2.2 1.9 2.5 Divorciado/a Casos 97.0 55.0 42.0 % casos 3.8 4.4 3.2 N.C. Casos 8.0 4.0 4.0 % casos 0.3 0.3 0.3 #Total cases Casos 2557 1256 1301 % casos 2557 1256 1301 Y la misma tabla pero con los estadísticos en las filas por bloque de tipo de estadístico data %&gt;% tab_cells(P33) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_rows&quot;) #Total Sexo de la persona entrevistada Hombre Mujer Estado civil de la persona entrevistada Casado/a Casos 1388.0 677.0 711.0 Soltero/a Casos 817.0 455.0 362.0 Viudo/a Casos 190.0 41.0 149.0 Separado/a Casos 57.0 24.0 33.0 Divorciado/a Casos 97.0 55.0 42.0 N.C. Casos 8.0 4.0 4.0 #Total cases Casos 2557 1256 1301 Casado/a % casos 54.3 53.9 54.7 Soltero/a % casos 32.0 36.2 27.8 Viudo/a % casos 7.4 3.3 11.5 Separado/a % casos 2.2 1.9 2.5 Divorciado/a % casos 3.8 4.4 3.2 N.C. % casos 0.3 0.3 0.3 #Total cases % casos 2557 1256 1301 5.2 Básica con múltiples Vamos a realizar ahora el mismo conjunto de tablas, pero en las filas, en lugar de una variable de tipo simple, vamos a utilizar una variable de tipo múltiple. Repetimos los cruces pero cambiamos las celdas donde ahora usaremos la variable P21A con la instrucción tab_cells(mdset(P21A01 %to% P21A03)). 5.2.1 De frecuencias, variable múltiple y sólo absolutos data %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(total_row_position = &quot;above&quot;, total_label = &quot;Total&quot;) %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer #Total 415 206 209 Medicamentos que recetan por adelantado (para que no falten) 225 108 117 Envases que han quedado sin usar porque cambiaron el tratamiento 136 70 66 Medicamentos que decidió no tomar 82 42 40 5.2.2 De frecuencias, variable múltiple, con porcentajes de columna Al igual que hicimos con las tablas marginales vamos a repetir esta tabla, pero en porcentaje de columna (vertical). data %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cpct(total_row_position = &quot;above&quot;, total_label = &quot;Total&quot;) %&gt;% # aquí señalo los porcentajes de columna tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer #Total 415 206 209 Medicamentos que recetan por adelantado (para que no falten) 54.2 52.4 56.0 Envases que han quedado sin usar porque cambiaron el tratamiento 32.8 34.0 31.6 Medicamentos que decidió no tomar 19.8 20.4 19.1 5.2.3 De frecuencias, variable múltiple, con porcentajes de fila Al igual que hicimos con las tablas marginales vamos a repetir esta tabla, pero en porcentaje de fila (horizontal). data %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_rpct(total_row_position = &quot;above&quot;, total_label = &quot;Total&quot;) %&gt;% # aquí señalo los porcentajes de fila tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer #Total 415 206 209 Medicamentos que recetan por adelantado (para que no falten) 100 48.0 52.0 Envases que han quedado sin usar porque cambiaron el tratamiento 100 51.5 48.5 Medicamentos que decidió no tomar 100 51.2 48.8 5.2.4 De frecuencias, variable múltiple, con porcentajes total muestra Al igual que hicimos con las tablas marginales vamos a repetir esta tabla, pero en porcentaje sobre el total de la muestra. data %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_tpct(total_row_position = &quot;above&quot;, total_label = &quot;Total&quot;) %&gt;% # aquí señalo los porcentajes total muestra tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer #Total 415 206 209 Medicamentos que recetan por adelantado (para que no falten) 54.2 26.0 28.2 Envases que han quedado sin usar porque cambiaron el tratamiento 32.8 16.9 15.9 Medicamentos que decidió no tomar 19.8 10.1 9.6 5.2.5 Combinaciones de los anteriores Vamos ahora a hacer combinaciones entre ellos. Advierto que cada vez se dificulta más la tabla en su lectura. Como dije inicialmente, me decanto más por tablas sencillas y con un sólo dato. data %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_columns&quot;) #Total Sexo de la persona entrevistada Casos % casos Hombre Mujer Casos % casos Casos % casos Medicamentos que recetan por adelantado (para que no falten) 225 54.2 108 52.4 117 56.0 Envases que han quedado sin usar porque cambiaron el tratamiento 136 32.8 70 34.0 66 31.6 Medicamentos que decidió no tomar 82 19.8 42 20.4 40 19.1 #Total cases 415 415 206 206 209 209 Y la misma tabla pero con los estadísticos en las filas combinando frecuencia y porcentaje data %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_columns&quot;) #Total Sexo de la persona entrevistada #Total Sexo de la persona entrevistada Casos Hombre Mujer % casos Hombre Mujer Casos Casos % casos % casos Medicamentos que recetan por adelantado (para que no falten) 225 108 117 54.2 52.4 56.0 Envases que han quedado sin usar porque cambiaron el tratamiento 136 70 66 32.8 34.0 31.6 Medicamentos que decidió no tomar 82 42 40 19.8 20.4 19.1 #Total cases 415 206 209 415 206 209 Y la misma tabla pero con los estadísticos en las filas combinando frecuencia y porcentaje data %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_rows&quot;) #Total Sexo de la persona entrevistada Hombre Mujer Medicamentos que recetan por adelantado (para que no falten) Casos 225.0 108.0 117.0 % casos 54.2 52.4 56.0 Envases que han quedado sin usar porque cambiaron el tratamiento Casos 136.0 70.0 66.0 % casos 32.8 34.0 31.6 Medicamentos que decidió no tomar Casos 82.0 42.0 40.0 % casos 19.8 20.4 19.1 #Total cases Casos 415 206 209 % casos 415 206 209 Y la misma tabla pero con los estadísticos en las filas por bloque de tipo de estadístico data %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_cases(label = &quot;Casos&quot;) %&gt;% tab_stat_cpct(label = &quot;% casos&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_rows&quot;) #Total Sexo de la persona entrevistada Hombre Mujer Medicamentos que recetan por adelantado (para que no falten) Casos 225.0 108.0 117.0 Envases que han quedado sin usar porque cambiaron el tratamiento Casos 136.0 70.0 66.0 Medicamentos que decidió no tomar Casos 82.0 42.0 40.0 #Total cases Casos 415 206 209 Medicamentos que recetan por adelantado (para que no falten) % casos 54.2 52.4 56.0 Envases que han quedado sin usar porque cambiaron el tratamiento % casos 32.8 34.0 31.6 Medicamentos que decidió no tomar % casos 19.8 20.4 19.1 #Total cases % casos 415 206 209 Recordamos que siempre con las múltiples existe la posibilidad de calcular los porcentajes con base respuesta en lugar de con base cuestionario (individuos). Para ello debes utilizar tab_stat_cpct_responses(). 5.3 Básica con estadísticos Del mismo modo que antes utilizábamos la tabla cruzada para obtener los casos de intersección entre las categorías de columna y las categorías de fila, ahora procederemos a hacer lo mismo pero con categorías en columnas y cálculo de estadísticos básicos en otro. En definitiva, calcular las medidas estadísticas para cada grupo creado por la variable que general las categorías. 5.3.1 Cruce entre variable simple y dos estadísticos Vamos a comenzar con las más simples, dos estadísticos (media y desviación) de una variable métrica (P3) calculados para una variable (P31) que genera dos categorías (hombre y mujer). Nótese el juego a realizar con más de 2 estadísticos con la ubicación de los mismos. data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Escala de satisfacción (1-10) con el funcionamiento del sistema sanitario español Media 7.3 7.3 7.4 Desviación 7.2 6.6 7.8 Hagamos ahora su traspuesta, es decir ubiquemos en filas P31 y en columnas var_lab(data$P3)=&quot;Satisfacción&quot; data %&gt;% tab_cells(P3) %&gt;% tab_rows(total(),P31) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot() #Total #Total Satisfacción Media 7.3 Sexo de la persona entrevistada Hombre Satisfacción Media 7.3 Mujer Satisfacción Media 7.4 #Total Satisfacción Desviación 7.2 Sexo de la persona entrevistada Hombre Satisfacción Desviación 6.6 Mujer Satisfacción Desviación 7.8 Recordemos que los estadísticos los podemos ir moviendo a nuestra necesidad para que se organicen de una forma u otra Dentro de las columnas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_columns&quot;) #Total Sexo de la persona entrevistada Media Desviación Hombre Mujer Media Desviación Media Desviación Satisfacción 7.3 7.2 7.3 6.6 7.4 7.8 Dentro de las filas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_rows&quot;) #Total Sexo de la persona entrevistada Hombre Mujer Satisfacción Media 7.3 7.3 7.4 Desviación 7.2 6.6 7.8 Como columnas separadas o fuera de columnas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_columns&quot;) #Total Sexo de la persona entrevistada #Total Sexo de la persona entrevistada Media Hombre Mujer Desviación Hombre Mujer Media Media Desviación Desviación Satisfacción 7.3 7.3 7.4 7.2 6.6 7.8 Como filas separadas o fuera de filas data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_rows&quot;) #Total Sexo de la persona entrevistada Hombre Mujer Satisfacción Media 7.3 7.3 7.4 Desviación 7.2 6.6 7.8 Repitamos ahora estas cuatro últimas tablas, pero en lugar de con una variable que genera grupos y de ellos se calcula la medida estadística, vamos a hacerlo con un cruce de categorías (un campo en columnas y otro en filas) y que en esos cruces, se calcule la medida estadística. Por ejemplo esta tabla me permitiría saber la media de P3 en los hombres de 18 a 25 años. data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Estado civil de la persona entrevistada Casado/a Satisfacción Media 7.3 7.5 7.2 Soltero/a Satisfacción Media 7.2 6.9 7.4 Viudo/a Satisfacción Media 7.9 7.2 8.1 Separado/a Satisfacción Media 6.7 6.5 6.9 Divorciado/a Satisfacción Media 7.5 8.3 6.3 N.C. Satisfacción Media 18.2 7.5 29.0 Casado/a Satisfacción Desviación 6.7 7.2 6.2 Soltero/a Satisfacción Desviación 7.4 4.6 9.8 Viudo/a Satisfacción Desviación 6.9 2.3 7.7 Separado/a Satisfacción Desviación 2.1 2.5 1.8 Divorciado/a Satisfacción Desviación 9.5 12.5 2.3 N.C. Satisfacción Desviación 32.3 2.4 46.0 y juguemos con la posición del cálculo estadística que ahora sí arrojará cuatro configuraciones diferentes. La primera con los estadísticos fuera de las filas data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_rows&quot;) # por defecto, sin lo ponemos muestra esta opción #Total Sexo de la persona entrevistada Hombre Mujer Estado civil de la persona entrevistada Casado/a Satisfacción Media 7.3 7.5 7.2 Soltero/a Satisfacción Media 7.2 6.9 7.4 Viudo/a Satisfacción Media 7.9 7.2 8.1 Separado/a Satisfacción Media 6.7 6.5 6.9 Divorciado/a Satisfacción Media 7.5 8.3 6.3 N.C. Satisfacción Media 18.2 7.5 29.0 Casado/a Satisfacción Desviación 6.7 7.2 6.2 Soltero/a Satisfacción Desviación 7.4 4.6 9.8 Viudo/a Satisfacción Desviación 6.9 2.3 7.7 Separado/a Satisfacción Desviación 2.1 2.5 1.8 Divorciado/a Satisfacción Desviación 9.5 12.5 2.3 N.C. Satisfacción Desviación 32.3 2.4 46.0 Los estadísticos dentro de las filas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_rows&quot;) #Total Sexo de la persona entrevistada Hombre Mujer Estado civil de la persona entrevistada Casado/a Satisfacción Media 7.3 7.5 7.2 Desviación 6.7 7.2 6.2 Soltero/a Satisfacción Media 7.2 6.9 7.4 Desviación 7.4 4.6 9.8 Viudo/a Satisfacción Media 7.9 7.2 8.1 Desviación 6.9 2.3 7.7 Separado/a Satisfacción Media 6.7 6.5 6.9 Desviación 2.1 2.5 1.8 Divorciado/a Satisfacción Media 7.5 8.3 6.3 Desviación 9.5 12.5 2.3 N.C. Satisfacción Media 18.2 7.5 29.0 Desviación 32.3 2.4 46.0 Los estadísticos dentro de las columnas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_columns&quot;) #Total Sexo de la persona entrevistada Media Desviación Hombre Mujer Media Desviación Media Desviación Estado civil de la persona entrevistada Casado/a Satisfacción 7.3 6.7 7.5 7.2 7.2 6.2 Soltero/a Satisfacción 7.2 7.4 6.9 4.6 7.4 9.8 Viudo/a Satisfacción 7.9 6.9 7.2 2.3 8.1 7.7 Separado/a Satisfacción 6.7 2.1 6.5 2.5 6.9 1.8 Divorciado/a Satisfacción 7.5 9.5 8.3 12.5 6.3 2.3 N.C. Satisfacción 18.2 32.3 7.5 2.4 29.0 46.0 Los estadísticos fuera de las columnas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), P31) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_columns&quot;) #Total Sexo de la persona entrevistada #Total Sexo de la persona entrevistada Media Hombre Mujer Desviación Hombre Mujer Media Media Desviación Desviación Estado civil de la persona entrevistada Casado/a Satisfacción 7.3 7.5 7.2 6.7 7.2 6.2 Soltero/a Satisfacción 7.2 6.9 7.4 7.4 4.6 9.8 Viudo/a Satisfacción 7.9 7.2 8.1 6.9 2.3 7.7 Separado/a Satisfacción 6.7 6.5 6.9 2.1 2.5 1.8 Divorciado/a Satisfacción 7.5 8.3 6.3 9.5 12.5 2.3 N.C. Satisfacción 18.2 7.5 29.0 32.3 2.4 46.0 ¿Hacemos lo mismo para una variable múltiple? 5.3.1.1 Tabulación cruzada (con cálculo estadístico) y múltiples Vamos a comenzar con las más simples, dos estadísticos (media y desviación) de una variable métrica (P3) calculados para una variable múltiple (P4_1 a P4_3) que genera categorías. Nótese el juego a realizar con más de 2 estadísticos con la ubicación de los mismos. data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot() #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Satisfacción Media 7.3 7.2 6.9 6.7 Desviación 7.2 6.4 1.5 1.7 Hagamos ahora su traspuesta, es decir ubiquemos en filas P21A y en columnas P3. data %&gt;% tab_cells(P3) %&gt;% tab_rows(total(),mdset(P21A01 %to% P21A03)) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot() #Total #Total Satisfacción Media 7.3 Medicamentos que recetan por adelantado (para que no falten) Satisfacción Media 7.2 Envases que han quedado sin usar porque cambiaron el tratamiento Satisfacción Media 6.9 Medicamentos que decidió no tomar Satisfacción Media 6.7 #Total Satisfacción Desviación 7.2 Medicamentos que recetan por adelantado (para que no falten) Satisfacción Desviación 6.4 Envases que han quedado sin usar porque cambiaron el tratamiento Satisfacción Desviación 1.5 Medicamentos que decidió no tomar Satisfacción Desviación 1.7 Recordemos que los estadísticos los podemos ir moviendo a nuestra necesidad para que se organicen de una forma u otra Dentro de columnas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_columns&quot;) #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Media Desviación Media Desviación Media Desviación Media Desviación Satisfacción 7.3 7.2 7.2 6.4 6.9 1.5 6.7 1.7 Dentro de filas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_rows&quot;) #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Satisfacción Media 7.3 7.2 6.9 6.7 Desviación 7.2 6.4 1.5 1.7 Fuera de columnas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_columns&quot;) #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Media Media Media Media Desviación Desviación Desviación Desviación Satisfacción 7.3 7.2 6.9 6.7 7.2 6.4 1.5 1.7 Fuera de filas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_rows&quot;) #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Satisfacción Media 7.3 7.2 6.9 6.7 Desviación 7.2 6.4 1.5 1.7 Repitamos ahora estas cuatro últimas tablas, pero en lugar de con una variable que genera grupos y de ellos se calcula la medida estadística, vamos a hacerlo con un cruce de categorías (un campo en columnas y otro en filas) y que en esos cruces, se calcule la medida estadística. Por ejemplo esta tabla me permitiría saber la media de P3 en los hombres de 18 a 25 años. data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot() #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Estado civil de la persona entrevistada Casado/a Satisfacción Media 7.3 6.7 6.7 7.0 Soltero/a Satisfacción Media 7.2 8.2 6.8 6.4 Viudo/a Satisfacción Media 7.9 7.3 7.8 5.0 Separado/a Satisfacción Media 6.7 7.8 5.3 5.0 Divorciado/a Satisfacción Media 7.5 6.4 7.1 8.7 N.C. Satisfacción Media 18.2 Casado/a Satisfacción Desviación 6.7 2.0 1.5 1.3 Soltero/a Satisfacción Desviación 7.4 11.4 1.4 2.0 Viudo/a Satisfacción Desviación 6.9 1.7 2.0 Separado/a Satisfacción Desviación 2.1 0.8 0.6 Divorciado/a Satisfacción Desviación 9.5 2.1 1.2 2.3 N.C. Satisfacción Desviación 32.3 y juguemos con la posición del cálculo estadística que ahora sí arrojará cuatro configuraciones diferentes. La primera con los estadísticos dentro de las filas es idéntica a la anterior (por defecto). data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_rows&quot;) # por defecto, sin lo ponemos muestra esta opción #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Estado civil de la persona entrevistada Casado/a Satisfacción Media 7.3 6.7 6.7 7.0 Soltero/a Satisfacción Media 7.2 8.2 6.8 6.4 Viudo/a Satisfacción Media 7.9 7.3 7.8 5.0 Separado/a Satisfacción Media 6.7 7.8 5.3 5.0 Divorciado/a Satisfacción Media 7.5 6.4 7.1 8.7 N.C. Satisfacción Media 18.2 Casado/a Satisfacción Desviación 6.7 2.0 1.5 1.3 Soltero/a Satisfacción Desviación 7.4 11.4 1.4 2.0 Viudo/a Satisfacción Desviación 6.9 1.7 2.0 Separado/a Satisfacción Desviación 2.1 0.8 0.6 Divorciado/a Satisfacción Desviación 9.5 2.1 1.2 2.3 N.C. Satisfacción Desviación 32.3 Los estadísticos fuera de las filas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_rows&quot;) #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Estado civil de la persona entrevistada Casado/a Satisfacción Media 7.3 6.7 6.7 7.0 Desviación 6.7 2.0 1.5 1.3 Soltero/a Satisfacción Media 7.2 8.2 6.8 6.4 Desviación 7.4 11.4 1.4 2.0 Viudo/a Satisfacción Media 7.9 7.3 7.8 5.0 Desviación 6.9 1.7 2.0 Separado/a Satisfacción Media 6.7 7.8 5.3 5.0 Desviación 2.1 0.8 0.6 Divorciado/a Satisfacción Media 7.5 6.4 7.1 8.7 Desviación 9.5 2.1 1.2 2.3 N.C. Satisfacción Media 18.2 Desviación 32.3 Los estadísticos dentro de las columnas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;inside_columns&quot;) #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Media Desviación Media Desviación Media Desviación Media Desviación Estado civil de la persona entrevistada Casado/a Satisfacción 7.3 6.7 6.7 2.0 6.7 1.5 7.0 1.3 Soltero/a Satisfacción 7.2 7.4 8.2 11.4 6.8 1.4 6.4 2.0 Viudo/a Satisfacción 7.9 6.9 7.3 1.7 7.8 2.0 5.0 Separado/a Satisfacción 6.7 2.1 7.8 0.8 5.3 0.6 5.0 Divorciado/a Satisfacción 7.5 9.5 6.4 2.1 7.1 1.2 8.7 2.3 N.C. Satisfacción 18.2 32.3 Los estadísticos fuera de las columnas  data %&gt;% tab_cells(P3) %&gt;% tab_cols(total(), mdset(P21A01 %to% P21A03)) %&gt;% tab_rows(P33) %&gt;% tab_stat_mean(label = &quot;Media&quot;) %&gt;% tab_stat_sd(label = &quot;Desviación&quot;) %&gt;% tab_pivot(stat_position = &quot;outside_columns&quot;) #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar #Total Medicamentos que recetan por adelantado (para que no falten) Envases que han quedado sin usar porque cambiaron el tratamiento Medicamentos que decidió no tomar Media Media Media Media Desviación Desviación Desviación Desviación Estado civil de la persona entrevistada Casado/a Satisfacción 7.3 6.7 6.7 7.0 6.7 2.0 1.5 1.3 Soltero/a Satisfacción 7.2 8.2 6.8 6.4 7.4 11.4 1.4 2.0 Viudo/a Satisfacción 7.9 7.3 7.8 5.0 6.9 1.7 2.0 Separado/a Satisfacción 6.7 7.8 5.3 5.0 2.1 0.8 0.6 Divorciado/a Satisfacción 7.5 6.4 7.1 8.7 9.5 2.1 1.2 2.3 N.C. Satisfacción 18.2 32.3 Bien, como has podido observar, el resultado no difiere cuando es múltiple a cuando es simple. Igual que hemos calculado la media y la desviación lo podemos hacer con otros estadísticos: media desviación máximo mínimo mediana suma error estándar un caso especial que calcula media, desviación y nº de casos algunos otros que iremos mostrando para temas muy específicos. "],["tse05.html", "Capítulo 6 Tablas especiales 6.1 Subgrupos (filtros en la tabla) 6.2 Bases y/o con anidación 6.3 Características avanzadas", " Capítulo 6 Tablas especiales En el capítulo actual introducimos ya en la reproducción de las tablas, algunas de las características que hacen muy especial a este paquete expss. Iremos introduciendo cada uno de los conceptos en el punto donde corresponda, dando la explicación de caso de uso, más que su explicación técnica. El usuario que quiera conocer más sobre ello, puede acudir a la guía de referencia de todas las opciones de este paquete. Aprenderemos a usar: tab_subgroup(), que permite hacer la tabla con una parte de los datos; %nest%, que permite anidar variables; total_row_label(), escribir textos libres en filas en la secuencia que se indique; recode(), recodificar en línea una variable (ver 7.1 ); var_lab(), modificar o asignar el texto de la variable; val_lab(), modificar o asignar los textos de los códigos; drop_rc(), borrar columnas o filas [drop_empty_rows() y drop_empty_cols()]; tab_sort_asc(), para ordenar ascendente o descendente tab_sort_desc(); uso de na_if, para eliminar valores de niveles que no se desean computar en el cálculo de estadísticos; uso de criterios, para establecer sencillos mecanismos de filtro como complemento a otras funciones. 6.1 Subgrupos (filtros en la tabla) Una de las primeras cuestiones que nos surge en muchas ocasiones es trabajar con subgrupos de la información original, bien porque deseamos una tabla de sólo un parte de la muestra o bien porque buscamos comparar determinados elementos en una misma tabla. Veamos las posibilidades y las situaciones de uso. En la siguiente tabla, filtramos la tabla para aquellos entrevistados que han declarado tener hijos (P34 == 1) por un lado y los que no popr otro (P34 == 2). Para ello usamos la instrucción tab_subgroup() e introducimos también la instrucción tab_row_label() donde escribimos una fila con texto libre. Puedes consultar en el capítulo 9 como se escriben las condiciones y cuáles son los operadores que se pueden utilizar expssademás tiene algunos opetradores propios que en este mismo capítulo incluiremos. data %&gt;% tab_subgroup(P34 == 1) %&gt;% tab_row_label(&#39;Entrevistado con hijos&#39;) %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P36) %&gt;% tab_stat_cases() %&gt;% tab_subgroup(P34 == 2) %&gt;% tab_row_label(&#39;Entrevistado sin hijos&#39;) %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P36) %&gt;% tab_stat_cases() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Entrevistado con hijos Estado de salud en general Muy bueno 175 85 90 Bueno 484 230 254 Regular 125 53 72 Malo 14 8 6 Muy malo 3 2 1 N.S. N.C. #Total cases 801 378 423 Entrevistado sin hijos Estado de salud en general Muy bueno 273 151 122 Bueno 930 490 440 Regular 442 191 251 Malo 72 32 40 Muy malo 19 6 13 N.S. 2 2 N.C. 2 1 1 #Total cases 1740 871 869 6.2 Bases y/o con anidación El concepto de base, no está contemplado como tal en EXPSS - SegmentaNet, pero podemos utilizar las diferentes combinaciones de instrucciones para poder obtener el resultado deseado. Por ejemplo, si queremos trabajar con bases de la variable P34 (entrevistado tiene hijos o no tiene hijos), y obtener réplica de la tabla para mabas categorías, lo podíamos hacer de la forma anterior, pero hay otra posibilidad y es utilizar la opción de añadir variables anidadas en filas o utilizar de forma simultánea las instrucciones tab_rows() y tab_cells(). En esta tabla hay algunas cosas a reseñar. En primer lugar P34 == 1 | P34 == 2 es la condición de los casos con los que deseamos trabajar. No queremos contemplar los NC. Sí, se podría hacer también con el na_if(), pero creemos más clara esta opción. Por otro lado, usamos tab_cols(), tab_rows() y tab_cells() lo que nos va a dar una publicación curiosa. Por último, los códigos de P34, redefinidos al principio del script, se muestran como en una primera columna, diferenciados claramente del resto. La variable en tab_cells() de la que se calcula el estadístico (número de casos) se muestra como en una segunda columna. Hemos dejado fuera la opción de No contesta aunque ya anticipamos que no tenía ningún caso. La función var_lab() permite asignar a una variable (data$P34) una lista (expresa con la función base de R denminada vector c()vector) de etiquetas donde el texto de la etiqueta va entrecomillado y el valor va igualado a la etiqueta. Es una forma muy simple a la par que práctica de etiquetar los valores de una variable. val_lab(data$P34) &lt;- c(&#39;Sí&#39; = 1, &#39;No&#39; = 2) data %&gt;% tab_subgroup(P34 == 1 | P34 == 2) %&gt;% tab_cols(total(), P31) %&gt;% tab_rows(P34) %&gt;% tab_cells(P36) %&gt;% tab_stat_cases() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Tenencia de hijos menores de 18 años No Estado de salud en general Muy bueno 273 151 122 Bueno 930 490 440 Regular 442 191 251 Malo 72 32 40 Muy malo 19 6 13 N.S. 2 2 N.C. 2 1 1 #Total cases 1740 871 869 Sí Estado de salud en general Muy bueno 175 85 90 Bueno 484 230 254 Regular 125 53 72 Malo 14 8 6 Muy malo 3 2 1 N.S. N.C. #Total cases 801 378 423 Si nos gusta esta opción, se le puede añadir un modificador llamado %nest% que nos va a permitir anidar esas bases de cálculo. El modificador %nest% nos permite anidar los niveles o categorías de las variables. Cualquiera de las tablas anteriores puede ser anidada en tantos niveles como se desee con la opción %nest%. Para que la tabla no se alargue horizontalmente, reasignamos el texto extra de la variable denominada P3bis. data$P3bis &lt;- recode(data$P3, 0:5 ~1, 6:10 ~2) var_lab(data$P3bis) &lt;- &#39;Satisfacción&#39; val_lab(data$P3bis) &lt;- c(&#39;1.Negativa&#39; = 1, &#39;2.Positiva&#39; = 2) val_lab(data$P34) &lt;- c(&#39;1.Sí&#39; = 1, &#39;2.No&#39; = 2) data %&gt;% tab_subgroup(P34 == 1 | P34 == 2) %&gt;% tab_cols(total(), P31) %&gt;% tab_rows(P3bis %nest% P34) %&gt;% tab_cells(P36) %&gt;% tab_stat_cases(total_row_position = &#39;none&#39;) %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Satisfacción 1.Negativa Tenencia de hijos menores de 18 años 1.Sí Estado de salud en general Muy bueno 35 22 13 Bueno 117 58 59 Regular 47 16 31 Malo 5 3 2 Muy malo 2 2 N.S. N.C. 2.No Estado de salud en general Muy bueno 42 23 19 Bueno 180 85 95 Regular 106 41 65 Malo 16 6 10 Muy malo 4 2 2 N.S. N.C. 9 Estado de salud en general Muy bueno Bueno Regular Malo Muy malo N.S. N.C. 2.Positiva Tenencia de hijos menores de 18 años 1.Sí Estado de salud en general Muy bueno 139 63 76 Bueno 365 170 195 Regular 78 37 41 Malo 9 5 4 Muy malo 1 1 N.S. N.C. 2.No Estado de salud en general Muy bueno 227 126 101 Bueno 746 404 342 Regular 334 150 184 Malo 55 25 30 Muy malo 15 4 11 N.S. 2 2 N.C. 2 1 1 9 Estado de salud en general Muy bueno Bueno Regular Malo Muy malo N.S. N.C. Si añadimos la instrucción drop_rc(), nótese la diferencia, pues desaparecen las filas y columnas sin información. data$P3bis &lt;- recode(data$P3, 0:5 ~1, 6:10 ~2) var_lab(data$P3bis) &lt;- &#39;Satisfacción&#39; val_lab(data$P3bis) &lt;- c(&#39;1.Negativa&#39; = 1, &#39;2.Positiva&#39; = 2) val_lab(data$P34) &lt;- c(&#39;1.Sí&#39; = 1, &#39;2.No&#39; = 2) data %&gt;% tab_subgroup(P34 == 1 | P34 == 2) %&gt;% tab_cols(total(), P31) %&gt;% tab_rows(P3bis %nest% P34) %&gt;% tab_cells(P36) %&gt;% tab_stat_cases(total_row_position = &#39;none&#39;) %&gt;% tab_pivot() %&gt;% drop_rc() #Total Sexo de la persona entrevistada Hombre Mujer Satisfacción 1.Negativa Tenencia de hijos menores de 18 años 1.Sí Estado de salud en general Muy bueno 35 22 13 Bueno 117 58 59 Regular 47 16 31 Malo 5 3 2 Muy malo 2 2 2.No Estado de salud en general Muy bueno 42 23 19 Bueno 180 85 95 Regular 106 41 65 Malo 16 6 10 Muy malo 4 2 2 2.Positiva Tenencia de hijos menores de 18 años 1.Sí Estado de salud en general Muy bueno 139 63 76 Bueno 365 170 195 Regular 78 37 41 Malo 9 5 4 Muy malo 1 1 2.No Estado de salud en general Muy bueno 227 126 101 Bueno 746 404 342 Regular 334 150 184 Malo 55 25 30 Muy malo 15 4 11 N.S. 2 2 N.C. 2 1 1 6.3 Características avanzadas Hagamos ahora lo mismo, pero combinando con un cálculo estadístico, por ejemplo nuevamente la media de P6C (atención recibida en consultas). Fíjemonos en la nueva aportación realizada. En el tab_cells(), se le está indicando que se trabaje con la variable P6C, pero que considere NA (valores nulos) todos aquello que sean mayores que 5. ¿Por qué? porque los códigos 8, no sabe y 9, no contesta, no queremos que entren en la media. Esto lo hacemos usando la función na_if(). Los criterios más básicos son: igual -&gt; equals, eq no igual -&gt; not_equals, neq, ne mayor que -&gt; greater, gt mayor o igual que -&gt; greater_or_equal, gte, ge menor que -&gt; less, lt menor o igual que -&gt; less_or_equal, lte, le Puede usarse la expresión larga o también cualquiera de las cortas. Por tanto, na_if(P6C, gt(5)) significa trabaja con la variable P6C considerando NA los valores mayores que 5. var_lab(data$P6C) &lt;- &#39;Valoración de la atención recibida&#39; data$P3bis &lt;- recode(data$P3, 0:5 ~1, 6:10 ~2) val_lab(data$P3bis) &lt;- c(&#39;1.Negativa&#39; = 1, &#39;2.Positiva&#39; = 2) val_lab(data$P34) &lt;- c(&#39;1.Sí&#39; = 1, &#39;2.No&#39; = 2) data %&gt;% tab_subgroup(P34 == 1 | P34 == 2) %&gt;% tab_cols(total(), P31) %&gt;% tab_rows(P3bis %nest% P34) %&gt;% tab_cells(P6C= na_if(P6C, gt(5))) %&gt;% tab_stat_mean() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer 1.Negativa Tenencia de hijos menores de 18 años 1.Sí Valoración de la atención recibida Mean 1.2 1.1 1.4 2.No Valoración de la atención recibida Mean 1.3 1.3 1.4 9 Valoración de la atención recibida Mean 2.Positiva Tenencia de hijos menores de 18 años 1.Sí Valoración de la atención recibida Mean 1.1 1.0 1.3 2.No Valoración de la atención recibida Mean 1.2 1.2 1.2 9 Valoración de la atención recibida Mean Se puede anidar también en filas y columnas. Vamos a reducir a dos el nivel de anidación para que se lea bien la tabla. data$P3bis &lt;- recode(data$P3, 0:5 ~1, 6:10 ~2) var_lab(data$P3bis) &lt;- &#39;Satisfacción&#39; val_lab(data$P3bis) &lt;- c(&#39;1.Negativa&#39; = 1, &#39;2.Positiva&#39; = 2) val_lab(data$P34) &lt;- c(&#39;1.Sí&#39; = 1, &#39;2.No&#39; = 2) data %&gt;% tab_cols(P31 %nest% P34) %&gt;% tab_rows(P3bis %nest% P33) %&gt;% tab_stat_cases(total_row_position=&#39;none&#39;) %&gt;% tab_pivot() Sexo de la persona entrevistada Hombre Mujer Tenencia de hijos menores de 18 años Tenencia de hijos menores de 18 años 1.Sí 2.No 9 1.Sí 2.No 9 Satisfacción 1.Negativa Estado civil de la persona entrevistada Casado/a #Total 70 73 1 70 87 1 Soltero/a #Total 20 63 26 74 Viudo/a #Total 1 9 1 19 Separado/a #Total 5 5 2 4 Divorciado/a #Total 5 6 6 6 N.C. #Total 1 1 2.Positiva Estado civil de la persona entrevistada Casado/a #Total 204 322 3 236 311 3 Soltero/a #Total 45 324 2 54 203 1 Viudo/a #Total 3 28 5 120 3 Separado/a #Total 4 10 10 17 Divorciado/a #Total 18 25 12 18 N.C. #Total 1 1 1 2 Como caso particular en muchos casos se requieren los subtotales de los niveles de anidación. Fíjate esta tabla y trata de ver las diferencias con la anterior. data %&gt;% tab_cols(P31 %nest% list(total(),P34)) %&gt;% tab_rows(P36 %nest% P33) %&gt;% tab_stat_cases() %&gt;% tab_sort_desc() %&gt;% tab_pivot() Sexo de la persona entrevistada Hombre Mujer #Total Tenencia de hijos menores de 18 años #Total Tenencia de hijos menores de 18 años 1.Sí 2.No 9 1.Sí 2.No 9 Estado de salud en general Bueno Estado civil de la persona entrevistada Casado/a #Total 410 171 236 3 386 191 195 #Total cases 410 171 236 3 386 191 195 Divorciado/a #Total 25 10 15 18 7 11 #Total cases 25 10 15 18 7 11 N.C. #Total 3 1 2 4 3 1 #Total cases 3 1 2 4 3 1 Separado/a #Total 13 6 7 14 8 6 #Total cases 13 6 7 14 8 6 Soltero/a #Total 254 39 214 1 215 44 170 1 #Total cases 254 39 214 1 215 44 170 1 Viudo/a #Total 19 3 16 60 4 55 1 #Total cases 19 3 16 60 4 55 1 Malo Estado civil de la persona entrevistada Casado/a #Total 20 5 15 28 3 25 #Total cases 20 5 15 28 3 25 Divorciado/a #Total 7 1 6 3 1 2 #Total cases 7 1 6 3 1 2 N.C. #Total #Total cases Separado/a #Total 3 3 1 1 #Total cases 3 3 1 1 Soltero/a #Total 8 2 6 4 2 2 #Total cases 8 2 6 4 2 2 Viudo/a #Total 2 2 10 10 #Total cases 2 2 10 10 Muy bueno Estado civil de la persona entrevistada Casado/a #Total 91 57 33 1 109 67 41 1 #Total cases 91 57 33 1 109 67 41 1 Divorciado/a #Total 9 6 3 8 4 4 #Total cases 9 6 3 8 4 4 N.C. #Total 1 1 #Total cases 1 1 Separado/a #Total 5 3 2 5 5 #Total cases 5 3 2 5 5 Soltero/a #Total 131 19 112 83 19 64 #Total cases 131 19 112 83 19 64 Viudo/a #Total 1 1 8 8 #Total cases 1 1 8 8 Muy malo Estado civil de la persona entrevistada Casado/a #Total 3 3 7 7 #Total cases 3 3 7 7 Divorciado/a #Total 2 2 3 3 #Total cases 2 2 3 3 N.C. #Total #Total cases Separado/a #Total 1 1 #Total cases 1 1 Soltero/a #Total 3 2 1 #Total cases 3 2 1 Viudo/a #Total 1 1 4 3 1 #Total cases 1 1 4 3 1 N.C. Estado civil de la persona entrevistada Casado/a #Total 1 1 #Total cases 1 1 Divorciado/a #Total #Total cases N.C. #Total #Total cases Separado/a #Total #Total cases Soltero/a #Total 1 1 #Total cases 1 1 Viudo/a #Total #Total cases N.S. Estado civil de la persona entrevistada Casado/a #Total 1 1 #Total cases 1 1 Divorciado/a #Total #Total cases N.C. #Total #Total cases Separado/a #Total #Total cases Soltero/a #Total 1 1 #Total cases 1 1 Viudo/a #Total #Total cases Regular Estado civil de la persona entrevistada Casado/a #Total 153 43 110 179 46 130 3 #Total cases 153 43 110 179 46 130 3 Divorciado/a #Total 12 4 8 10 6 4 #Total cases 12 4 8 10 6 4 N.C. #Total #Total cases Separado/a #Total 3 3 12 3 9 #Total cases 3 3 12 3 9 Soltero/a #Total 58 5 53 59 15 44 #Total cases 58 5 53 59 15 44 Viudo/a #Total 18 1 17 67 2 64 1 #Total cases 18 1 17 67 2 64 1 Efectivamente, han aparecido más columnas porque hemos anidado la columna de totales a la primera variable en lugar de usar el campo, hemos usado una lista de campos y además hemos ordenado de forma descendente respecto de la columna de total. Pues hasta aquí una nueva sección completada. Continuamos en la siguiente sección. "],["tse06.html", "Capítulo 7 Otras utilidades y tablas especiales 7.1 Recodificar 7.2 Cuadros 7.3 Ponderación 7.4 Subtotales y NETS 7.5 Top y Bottom", " Capítulo 7 Otras utilidades y tablas especiales 7.1 Recodificar Aunque ya en el capítulo anterior hicimos una breve incursión en el uso de la recodificación, el paquete expss dispone de una serie de opciones muy interesantes acerca de este funcionalidad que usamos mucho en nuestro trabajo diario. La función recode cambia la codificación de una variable en el contexto que se utiliza. Puede ser usada también para reorganizar o consolidar los valores de una variable existente en función de las condiciones. El diseño de esta función está inspirada en la utilidad RECODE de SPSS. El usuario facilita una secuencia de recodificaciones proporcionadas en forma de fórmulas. Por ejemplo, 1:2 ~ 1 significa que todos los valores 1 y 2 se reemplazarán con 1. Cada valor se recodificará solo una vez, es decir, sea realiza una única pasada por el registro empezando por el 1 y acabando por el N. Dos formas de uso: Si recode() se usa como funcionalidad diferenciada, en este proceso de asignación aquellos valores que no cumplan ninguna condición permanecen sin cambios. * Si recode()se usa dentro de una tabla, los valores de recodificación () que no cumplen ninguna condición serán reemplazados por NA. Se pueden usar valores o condiciones lógicas más sofisticadas y funciones como condición. Hay varias funciones especiales para su uso como criterios; para más detalles, consulte los criterios 11.5 en su sección 9. El uso común se parece a este: recode(x, 1:2 ~ -1, 3 ~ 0, 4:5 ~ 1, 99 ~ NA). Se puede observar que a los valores originales 1 y 2 se les imputa un -1, al 3 un 0, y a los valores 4 y 5 se les imputa un 1, el 99 se convierte en NA (valor perdido). Para más información, ver detalles y ejemplos a continuación. Te dejamos los ejemplos del autor que ilustran muy bien las posibilidades de esta funcionalidad. Se reproducen los ejemplos de recodificación extraídos del manual de SPSS. Se utilizan datos ficticios generados en línea. # RECODE V1 TO V3 (0=1) (1=0) (2, 3=-1) (9=9) (ELSE=SYSMIS) v1 = c(0, 1, 2, 3, 9, 10) # se crea la variable v1 ## [1] 0 1 2 3 9 10 recode(v1) = c(0 ~ 1, 1 ~ 0, 2:3 ~ -1, 9 ~ 9, TRUE ~ NA) v1 ## [1] 1 0 -1 -1 9 NA # RECODE QVAR(1 THRU 5=1)(6 THRU 10=2)(11 THRU HI=3)(ELSE=0). qvar = c(1:20, 97, NA, NA) recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, 11 %thru% hi ~ 3, TRUE ~ 0) ## [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 0 0 # the same result recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, ge(11) ~ 3, TRUE ~ 0) ## [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 0 0 # RECODE STRNGVAR (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;=&#39;A&#39;)(&#39;D&#39;, &#39;E&#39;, &#39;F&#39;=&#39;B&#39;)(ELSE=&#39; &#39;). strngvar = LETTERS recode(strngvar, c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) ~ &#39;A&#39;, c(&#39;D&#39;, &#39;E&#39;, &#39;F&#39;) ~ &#39;B&#39;, TRUE ~ &#39; &#39;) ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; ## [20] &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; # recode in place. Note that we recode only first six letters recode(strngvar) = c(c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) ~ &#39;A&#39;, c(&#39;D&#39;, &#39;E&#39;, &#39;F&#39;) ~ &#39;B&#39;) strngvar ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # RECODE AGE (MISSING=9) (18 THRU HI=1) (0 THRU 18=0) INTO VOTER. age = c(NA, 2:40, NA) voter = recode(age, NA ~ 9, 18 %thru% hi ~ 1, 0 %thru% 18 ~ 0) voter ## [1] 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [39] 1 1 9 # the same result with &#39;%into%&#39; recode(age, NA ~ 9, 18 %thru% hi ~ 1, 0 %thru% 18 ~ 0) %into% voter2 voter2 ## [1] 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [39] 1 1 9 # recode with adding labels voter = recode(age, &quot;Refuse to answer&quot; = NA ~ 9,&quot;Vote&quot; = 18 %thru% hi ~ 1, &quot;Don&#39;t vote&quot; = 0 %thru% 18 ~ 0) voter ## VALUES: ## 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9 ## VALUE LABELS: ## 0 Don&#39;t vote ## 1 Vote ## 9 Refuse to answer # recoding with labels ol = c(1:7, 99) var_lab(ol) = &quot;Liking&quot; #texto extra val_lab(ol) = c(&#39;Disgusting&#39; =1, &#39;Very Poor&#39;=2, &#39;Poor&#39;=3, &#39;So-so&#39;=4, &#39;Good&#39;=5, &#39;Very good&#39;=6, &#39;Excellent&#39;=7, &#39;Hard to say&#39;=99) #etiquetas códigos recode(ol, 1:3 ~ 1, 5:7 ~ 7, TRUE ~ copy, with_labels = TRUE) ## LABEL: Liking ## VALUES: ## 1, 1, 1, 4, 7, 7, 7, 99 ## VALUE LABELS: ## 1 Disgusting/Very Poor/Poor ## 4 So-so ## 7 Good/Very good/Excellent ## 99 Hard to say # &#39;rec&#39; is a shortcut for recoding with labels. Same result: rec(ol, 1:3 ~ 1, 5:7 ~ 7, TRUE ~ copy) ## LABEL: Liking ## VALUES: ## 1, 1, 1, 4, 7, 7, 7, 99 ## VALUE LABELS: ## 1 Disgusting/Very Poor/Poor ## 4 So-so ## 7 Good/Very good/Excellent ## 99 Hard to say # another method of combining labels recode(ol, 1:3 ~ 1, 5:7 ~ 7, TRUE ~ copy, with_labels = TRUE, new_label = &quot;range&quot;) ## LABEL: Liking ## VALUES: ## 1, 1, 1, 4, 7, 7, 7, 99 ## VALUE LABELS: ## 1 Disgusting - Poor ## 4 So-so ## 7 Good - Excellent ## 99 Hard to say # example with from/to notation # RECODE QVAR(1 THRU 5=1)(6 THRU 10=2)(11 THRU HI=3)(ELSE=0). list_from = list(1 %thru% 5, 6 %thru% 10, ge(11), TRUE) list_to = list(1, 2, 3, 0) recode(qvar, from_to(list_from, list_to)) ## [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 0 0 list_from = list(NA, 18 %thru% hi, 0 %thru% 18) list_to = list(&quot;Refuse to answer&quot; = 9, &quot;Vote&quot; = 1, &quot;Don&#39;t vote&quot; = 0) voter = recode(age, from_to(list_from, list_to)) voter ## VALUES: ## 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9 ## VALUE LABELS: ## 0 Don&#39;t vote ## 1 Vote ## 9 Refuse to answer # &#39;ifs&#39; examples a = 1:5 b = 5:1 a ## [1] 1 2 3 4 5 b ## [1] 5 4 3 2 1 ifs(b&gt;3 ~ 1) # c(1, 1, NA, NA, NA) ## [1] 1 1 NA NA NA ifs(b&gt;3 ~ 1, TRUE ~ 3) # c(1, 1, 3, 3, 3) ## [1] 1 1 3 3 3 ifs(b&gt;3 ~ 1, a&gt;4 ~ 7, TRUE ~ 3) # c(1, 1, 3, 3, 7) ## [1] 1 1 3 3 7 ifs(b&gt;3 ~ a, TRUE ~ 42) # c(1, 2, 42, 42, 42) ## [1] 1 2 42 42 42 El recode()puede ser utilizado como funcionalidad separada y con asignación o dentro de la definición de una variable. Por ejemplo: v1 &lt;- c(1,2,3,2,1,2,3,4,5,6,5,4,3,2,1) v2 &lt;- v1 v1 ## [1] 1 2 3 2 1 2 3 4 5 6 5 4 3 2 1 v2 ## [1] 1 2 3 2 1 2 3 4 5 6 5 4 3 2 1 v1 &lt;- recode(v1, 1:5 ~ 1, 6:10 ~ 2) mean(v1,na.rm=TRUE) ## [1] 1.066667 mean(recode(v2, 1:5 ~ 1, 6:10 ~ 2), na.rm=TRUE) ## [1] 1.066667 v1 ## [1] 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 v2 ## [1] 1 2 3 2 1 2 3 4 5 6 5 4 3 2 1 Nótese que la diferencia estriba en que mientras que al finalizar el proceso v1 tiene solo valores 1 y 2 recodificados, v2 (copia de v1) mantiene los valores originales. 7.2 Cuadros En ocasiones es interesante reproducir algún tipo de cuadro que se ha presentado al entrevistado (baterías de ítems, cuadros, rejillas o grids, grillas o tablas de ítems, son sinónimos). Por ejemplo la pregunta P9 del cuestionario nos presenta un cuadro en el que hay hasta 7 ítems valorados de 1 a 10, con los valores 98 y 99 como NS y NC respectivamente. Así que vamos a procesar esas tablas como cuadros. Nuestro script es el siguiente  data %&gt;% tab_cells(P901 %to% P907) %&gt;% tab_stat_cpct() %&gt;% tab_pivot() #Total Los cuidados y la atención recibida del personal médico 1 Totalmente insatisfactorio 0.6 2 0.2 3 0.9 4 2.1 5 6.8 6 9.9 7 18.4 8 25.9 9 15.1 10 Totalmente satisfactorio 18.5 N.S. 1.3 N.C. 0.2 #Total cases 2557 Los cuidados y la atención recibida del personal de enfermería 1 Totalmente insatisfactorio 0.4 2 0.4 3 0.4 4 1.4 5 6.1 6 10.4 7 17.4 8 26.1 9 14.8 10 Totalmente satisfactorio 16.6 N.S. 5.9 N.C. 0.2 #Total cases 2557 La confianza y seguridad que transmite el personal médico 1 Totalmente insatisfactorio 1.1 2 0.7 3 0.9 4 2.1 5 6.5 6 9.2 7 16.4 8 23.5 9 16.1 10 Totalmente satisfactorio 21.2 N.S. 1.8 N.C. 0.4 #Total cases 2557 La confianza y seguridad que transmite el personal de enfermería 1 Totalmente insatisfactorio 0.4 2 0.5 3 0.7 4 1.4 5 6.2 6 9.3 7 18.7 8 24.4 9 14.1 10 Totalmente satisfactorio 17.8 N.S. 6.1 N.C. 0.2 #Total cases 2557 El tiempo dedicado por el médico o la médica a cada enfermo o enferma 1 Totalmente insatisfactorio 1.4 2 1.7 3 2.6 4 4.8 5 11.5 6 13.6 7 17.1 8 18.3 9 11.5 10 Totalmente satisfactorio 15.1 N.S. 2.1 N.C. 0.2 #Total cases 2557 El conocimiento del historial y seguimiento de los problemas de salud de cada usuario o usuaria 1 Totalmente insatisfactorio 1.6 2 1.0 3 1.5 4 3.7 5 7.4 6 10.7 7 16.5 8 21.2 9 13.0 10 Totalmente satisfactorio 18.3 N.S. 4.7 N.C. 0.4 #Total cases 2557 La información recibida sobre su problema de salud 1 Totalmente insatisfactorio 1.4 2 1.1 3 1.7 4 3.1 5 7.4 6 10.4 7 17.0 8 21.5 9 15.0 10 Totalmente satisfactorio 18.3 N.S. 2.7 N.C. 0.4 #Total cases 2557 Esta sería la salida lógica que damos a la tabla. Sin embargo utilizando algunos pequeños trucos, podemos presentarlo así. val_lab(data$P901) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) val_lab(data$P902) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) val_lab(data$P903) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) val_lab(data$P904) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) val_lab(data$P905) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) val_lab(data$P906) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) val_lab(data$P907) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) data %&gt;% tab_cells(&#39;|&#39;=unvr(P901)) %&gt;% tab_stat_cpct(label=var_lab(P901), total_row_position=&#39;none&#39;) %&gt;% tab_stat_mean_sd_n(label=&#39;P901&#39;) %&gt;% tab_cells(&#39;|&#39;=unvr(P902)) %&gt;% tab_stat_cpct(label=var_lab(P902), total_row_position=&#39;none&#39;) %&gt;% tab_stat_mean_sd_n(label=&#39;P901&#39;) %&gt;% tab_cells(&#39;|&#39;=unvr(P903)) %&gt;% tab_stat_cpct(label=var_lab(P903), total_row_position=&#39;none&#39;) %&gt;% tab_stat_mean_sd_n(label=&#39;P901&#39;) %&gt;% tab_cells(&#39;|&#39;=unvr(P904)) %&gt;% tab_stat_cpct(label=var_lab(P904), total_row_position=&#39;none&#39;) %&gt;% tab_stat_mean_sd_n(label=&#39;P901&#39;) %&gt;% tab_cells(&#39;|&#39;=unvr(P905)) %&gt;% tab_stat_cpct(label=var_lab(P905), total_row_position=&#39;none&#39;) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_cells(&#39;|&#39;=unvr(P906)) %&gt;% tab_stat_cpct(label=var_lab(P906), total_row_position=&#39;none&#39;) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_cells(&#39;|&#39;=unvr(P907)) %&gt;% tab_stat_cpct(label=var_lab(P907), total_row_position=&#39;none&#39;) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_pivot(stat_position=&#39;inside_columns&#39;) %&gt;% t() 1 2 3 4 5 6 7 8 9 10 N.S. N.C. Mean Std. dev. Unw. valid N #Total Los cuidados y la atención recibida del personal médico 0.6 0.2 0.9 2.1 6.8 9.9 18.4 25.9 15.1 18.5 1.3 0.2 P901 9.1 11.2 2557 Los cuidados y la atención recibida del personal de enfermería 0.4 0.4 0.4 1.4 6.1 10.4 17.4 26.1 14.8 16.6 5.9 0.2 P901.1 13.2 21.6 2557 La confianza y seguridad que transmite el personal médico 1.1 0.7 0.9 2.1 6.5 9.2 16.4 23.5 16.1 21.2 1.8 0.4 P901.2 9.7 13.2 2557 La confianza y seguridad que transmite el personal de enfermería 0.4 0.5 0.7 1.4 6.2 9.3 18.7 24.4 14.1 17.8 6.1 0.2 P901.3 13.5 22.1 2557 El tiempo dedicado por el médico o la médica a cada enfermo o enferma 1.4 1.7 2.6 4.8 11.5 13.6 17.1 18.3 11.5 15.1 2.1 0.2 9.2 13.8 2557 El conocimiento del historial y seguimiento de los problemas de salud de cada usuario o usuaria 1.6 1 1.5 3.7 7.4 10.7 16.5 21.2 13 18.3 4.7 0.4 .1 12 19.9 2557 La información recibida sobre su problema de salud 1.4 1.1 1.7 3.1 7.4 10.4 17 21.5 15 18.3 2.7 0.4 10.4 16 2557 ¿Qué hemos hecho?, hemos limpiado el texto de la variable utilizando la función '|'=unvr() y ese mismo texto extra de la variable var_lab() se lo hemos asignado al estadístico con label. De esta forma el resultado es el que ves. Desafortunadamente, hay un pequeño bug del que está informado el autor, de no poder situar la media y/o la desviación típica en la misma fila. Para hacerlo hay que unir dos tablas. Como esperamos esté resuelto en breve, no damos la solución por no complicar más la salida. 7.3 Ponderación Otro de los aspectos fundamentales en la investigación de mercados es la ponderación. Lo primero que debemos entender es el propio concepto de ponderación. En definitiva, es hacer que cada registro (% de casos o casos o estadísticos) en lugar de contar como un caso (frecuencia 1) , cuente como n casos, siendo n el valor de otro campo (indicado en weight() -peso-) del marco de datos. Este peso ha sido obtenido por un procedimiento llamado equilibraje (raking). Aquí muestro la tabla, sin ponderar  data %&gt;% tab_cols(total(),P3 ) %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_stat_cpct() %&gt;% tab_pivot() #Total Satisfacción 1 Muy insatisfecho/a 2 3 4 5 6 7 8 9 10 Muy satisfecho/a N.S. N.C. Medicamentos que recetan por adelantado (para que no falten) 54.2 83.3 80 25 68.8 51.9 47.9 50.0 57.9 61.3 58.3 100 Envases que han quedado sin usar porque cambiaron el tratamiento 32.8 50 25.0 34.6 32.4 39.6 30.5 32.3 25.0 Medicamentos que decidió no tomar 19.8 16.7 20 25 12.5 19.2 26.8 19.8 15.8 22.6 16.7 #Total cases 415 6 5 8 16 52 71 106 95 31 24 1 El estudio del CIS que estamos trabajando tiene una variable denominada PESO que contiene el coeficiente de ponderación para adaptarse a la población real española. Aquí dejamos la anterior tabla, pero ponderada. Véase las diferencias entre todos los valores. data %&gt;% tab_cols(total(),P3 ) %&gt;% tab_weight(PESO) %&gt;% tab_cells(mdset(P21A01 %to% P21A03)) %&gt;% tab_stat_cpct() %&gt;% tab_pivot() #Total Satisfacción 1 Muy insatisfecho/a 2 3 4 5 6 7 8 9 10 Muy satisfecho/a N.S. N.C. Medicamentos que recetan por adelantado (para que no falten) 54.7 80.3 88.6 19.8 63.6 55.5 44.5 52.5 57.1 64.3 66.4 100 Envases que han quedado sin usar porque cambiaron el tratamiento 31.0 56.2 27.5 31.9 31.9 37.7 27.6 30.0 19.8 Medicamentos que decidió no tomar 21.2 19.7 11.4 24.0 17.3 18.3 30.1 19.8 18.6 25.7 13.8 #Total cases 415 6 5 8 16 52 71 106 95 31 24 1 Aunque este manual se refiere únicamente a tablas, es bastante habitual obtener en toda ponderación la denominada eficiencia de la misma. Este análisis lo realizamos utilizando R como calculadora. Podemos hacer una análisis de la variable PESO y de su eficiencia. mean.peso &lt;- mean(data$PESO, na.rm=TRUE) sd.peso &lt;- sd(data$PESO, na.rm=TRUE) ratio &lt;- sd.peso/mean.peso eficiencia &lt;- (1/(1+(ratio^2)))*100 eficiencia &lt;- round(eficiencia,2) Puede observarse como la eficiencia de la ponderación es del 76.79 %. 7.4 Subtotales y NETS Otra de las funcionalidades básicas en nuestro trabajo de análisis es el uso de subtotales y/o netos. El objetivo de ambas funciones es reagrupar los códigos de una determinada variable, permitiendo observar acumulados de frecuencia. El paquete expss hace una diferenciación entre ambos que mostraremos seguidamente. 7.4.1 Subtotales El uso de tab_subtotal_rows o tab_subtotal_cols o tab_subtotal_cells añade subtotales a un conjunto de categorías de la variable sobre la que se aplique. Si se introduce un texto se utilizará el mismo, pero si no se añade la palabra TOTAL. Debes tener en cuenta que si las agrupaciones de categorías que realizas se solapan, también se solaparán los recuentos en el cálculo de subtotales. Estos subtotales pueden ser aplicados a las variables del banco de datos. val_lab(data$P901) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) data %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P901) %&gt;% tab_subtotal_cells(&#39;NO SATISFACTORIO&#39;= 1:5, 6:8, &#39;SATISFACTORIO&#39;=9:10) %&gt;% tab_stat_cpct() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Los cuidados y la atención recibida del personal médico 1 0.6 0.6 0.6 2 0.2 0.2 0.2 3 0.9 0.9 1.0 4 2.1 2.4 1.8 5 6.8 5.6 7.9 NO SATISFACTORIO 10.6 9.7 11.5 6 9.9 9.5 10.4 7 18.4 20.6 16.2 8 25.9 27.8 24.1 TOTAL 6/7/8 54.2 57.9 50.7 9 15.1 14.4 15.7 10 18.5 16.3 20.7 SATISFACTORIO 33.6 30.7 36.4 N.S. 1.3 1.5 1.1 N.C. 0.2 0.2 0.3 #Total cases 2557 1256 1301 Nótese que en el ejemplo han sido utilizados textos en solo dos de los tres subtotales que se han calculado. Si no se introduce texto, es cuando se usa la palabra TOTAL. Nótese también que por defecto los subtotales aparecen detrás del último valor del grupo, detrás del 5, detrás del 8 y detrás del 10. Existe la posibilidad de determinar mediante una instrucción como deben aparecer. El modificador o parámetro position con posibles valores \"below\", \"above\", \"top\" o \"bottom\" indicarán el lugar donde se deben imprimir. Del mismo modo, se puede forzar a que sea el propio sistema quien determine las etiquetas del subtotal generado. Así el modificador prefix puede determinar un prefijo para todas las etiquetas siendo TOTAL el valor por defecto, y también el modificador new_labelque permite indicar si la etiqueta se construye usando las etiquetas originales respondiendo a allque la usa todas, range la primera y la última, first la primera del grupo y last la última del grupo. Con todo ello, podríamos modificar nuestro ejemplo a: val_lab(data$P901) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) data %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P901) %&gt;% tab_subtotal_cells(1:5, 6:8, 9:10, position = &#39;bottom&#39;, prefix =&#39;SUBT&#39;, new_label=&#39;range&#39;) %&gt;% tab_stat_cpct() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Los cuidados y la atención recibida del personal médico 1 0.6 0.6 0.6 2 0.2 0.2 0.2 3 0.9 0.9 1.0 4 2.1 2.4 1.8 5 6.8 5.6 7.9 6 9.9 9.5 10.4 7 18.4 20.6 16.2 8 25.9 27.8 24.1 9 15.1 14.4 15.7 10 18.5 16.3 20.7 N.S. 1.3 1.5 1.1 N.C. 0.2 0.2 0.3 SUBT1 - 5 10.6 9.7 11.5 SUBT6 - 8 54.2 57.9 50.7 SUBT9 - 10 33.6 30.7 36.4 #Total cases 2557 1256 1301 7.4.2 NETS El uso de tab_net_rows() o tab_net_cols() o tab_net_cells() sustituye por netos (subtotales) a un conjunto de categorías de la variable sobre la que se aplique. Si se introduce un texto se utilizará el mismo, pero si no es así, se añade la palabra TOTAL. Debes tener en cuenta que si las agrupaciones de categorías que realizas se solapan, también se solaparán los recuentos en el cálculo de netos. Estos netos pueden ser aplicados a las variables del banco de datos. La terminología de NET suele ser muy aplicada en las variables de tipo múltiple, para agrupar conceptos similares. En nuestro ejemplo por mantener la coherencia con el uso de subtotal lo aplicaremos sin embargo con una variable numérica de valoración. val_lab(data$P901) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) data %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P901) %&gt;% tab_net_cells(&#39;NO SATISFACTORIO&#39;= 1:5, 6:8, &#39;SATISFACTORIO&#39;=9:10) %&gt;% tab_stat_cpct() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Los cuidados y la atención recibida del personal médico NO SATISFACTORIO 10.6 9.7 11.5 TOTAL 6/7/8 54.2 57.9 50.7 SATISFACTORIO 33.6 30.7 36.4 N.S. 1.3 1.5 1.1 N.C. 0.2 0.2 0.3 #Total cases 2557 1256 1301 Nótese que en el ejemplo han sido utilizados textos en solo dos de los tres nets que se han calculado. Si no se introduce texto, es cuando se usa la palabra TOTAL. Nótese también que por defecto los subtotales aparecen detrás del último valor del grupo, detrás del 5, detrás del 8 y detrás del 10. Existe la posibilidad de determinar mediante una instrucción como deben aparecer. El modificador o parámetro position con posibles valores \"below\", \"above\", \"top\" o \"bottom\" indicarán el lugar donde se deben imprimir. Del mismo modo, se puede forzar a que sea el propio sistema quien determine las etiquetas del subtotal generado. Así el modificador prefix puede determinar un prefijo para todas las etiquetas siendo TOTAL el valor por defecto, y también el modificador new_labelque permite indicar si la etiqueta se construye usando las etiquetas originales respondiendo a allque la usa todas, range la primera y la última, first la primera del grupo y last la última del grupo. Podríamos modificar nuestro ejemplo a: val_lab(data$P901) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) data %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P901) %&gt;% tab_net_cells(1:5, 6:8, 9:10, position = &#39;top&#39;, prefix =&#39;NET&#39;, new_label=&#39;range&#39;) %&gt;% tab_stat_cpct() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Los cuidados y la atención recibida del personal médico NET1 - 5 10.6 9.7 11.5 NET6 - 8 54.2 57.9 50.7 NET9 - 10 33.6 30.7 36.4 N.S. 1.3 1.5 1.1 N.C. 0.2 0.2 0.3 #Total cases 2557 1256 1301 Puedes preguntarte el porqué del position si en un NET realmente se eliminan los códigos originales, pero esto no tiene por qué ser así. Tanto el subtotal como el net tienen la posibilidad de variar este hecho utilizando el modificar add con valores TRUE o FALSE que mantendría o no los códigos originales. No obstante, en nuestro ejmplo como hay valores no agrupados (NS y NC) aquí la posición sí es relevante. 7.5 Top y Bottom Por último otra utilidad no menos importante que las anterior y no menos utilizada. El cálculo del top y el bottom de una escala. Para ello, vamos a basarnos en algo que ya hemos visto en las tablas anteriores, la recodificación y el cómo reutilizamos la posibilidad de las variables múltiples. Planteemos una situación en la que deseamos que la variable P901 se muestre de forma segmentada y conjuntamente cada uno de sus valores. Llamamos TOP a la agrupación en una columna o fila de tabla de aquellas categorías con las valoraciones más altas (por ejemplo 9 y 10) y BOTTOM a las más bajas (por ejemplo 1,2,3,4,5 y 6 o 1:6 como sabemos). Queremos que en la tabla se muestre ambas categorías. ¿Como la hacemos? Este es script. val_lab(data$P901) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) data %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P901) %&gt;% tab_subtotal_cells(&#39;Bottom&#39;= 1:6, &#39;Top&#39;=9:10) %&gt;% tab_stat_cpct() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Los cuidados y la atención recibida del personal médico 1 0.6 0.6 0.6 2 0.2 0.2 0.2 3 0.9 0.9 1.0 4 2.1 2.4 1.8 5 6.8 5.6 7.9 6 9.9 9.5 10.4 Bottom 20.6 19.2 21.9 7 18.4 20.6 16.2 8 25.9 27.8 24.1 9 15.1 14.4 15.7 10 18.5 16.3 20.7 Top 33.6 30.7 36.4 N.S. 1.3 1.5 1.1 N.C. 0.2 0.2 0.3 #Total cases 2557 1256 1301 Controlando más algunos aspectos de la publicación de la tabla  val_lab(data$P901) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) data %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P901) %&gt;% tab_subtotal_cells(&#39;Bottom&#39;= 1:6, &#39;Top&#39;=9:10, position =&#39;bottom&#39;) %&gt;% tab_stat_cpct(total_row_position=&#39;below&#39;) %&gt;% tab_cells(na_if(P901, gt(10))) %&gt;% tab_stat_mean() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Los cuidados y la atención recibida del personal médico 1 0.6 0.6 0.6 2 0.2 0.2 0.2 3 0.9 0.9 1.0 4 2.1 2.4 1.8 5 6.8 5.6 7.9 6 9.9 9.5 10.4 7 18.4 20.6 16.2 8 25.9 27.8 24.1 9 15.1 14.4 15.7 10 18.5 16.3 20.7 N.S. 1.3 1.5 1.1 N.C. 0.2 0.2 0.3 Bottom 20.6 19.2 21.9 Top 33.6 30.7 36.4 #Total cases 2557 1256 1301 Mean 7.7 7.7 7.8 Con subtotales abajo val_lab(data$P901) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) data %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P901) %&gt;% tab_subtotal_cells(&#39;Bottom&#39;= 1:6, &#39;Top&#39;=9:10, position =&#39;below&#39;) %&gt;% tab_stat_cpct(total_row_position=&#39;below&#39;) %&gt;% tab_cells(na_if(P901, gt(10))) %&gt;% tab_stat_mean() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Los cuidados y la atención recibida del personal médico 1 0.6 0.6 0.6 2 0.2 0.2 0.2 3 0.9 0.9 1.0 4 2.1 2.4 1.8 5 6.8 5.6 7.9 6 9.9 9.5 10.4 Bottom 20.6 19.2 21.9 7 18.4 20.6 16.2 8 25.9 27.8 24.1 9 15.1 14.4 15.7 10 18.5 16.3 20.7 Top 33.6 30.7 36.4 N.S. 1.3 1.5 1.1 N.C. 0.2 0.2 0.3 #Total cases 2557 1256 1301 Mean 7.7 7.7 7.8 O también  val_lab(data$P901) &lt;- c(&#39;1&#39;=1, &#39;2&#39;=2, &#39;3&#39;=3, &#39;4&#39;=4, &#39;5&#39;=5, &#39;6&#39;=6, &#39;7&#39;=7, &#39;8&#39;=8, &#39;9&#39;=9, &#39;10&#39;=10, &#39;N.S.&#39;=98, &#39;N.C.&#39;=99) data %&gt;% tab_cols(total(), P31) %&gt;% tab_cells(P901) %&gt;% tab_net_cells(&#39;Top&#39;=9:10, &#39;Bottom&#39; = 1:6) %&gt;% tab_stat_cpct(total_row_position=&#39;below&#39;) %&gt;% tab_cells(na_if(P901, gt(10))) %&gt;% tab_stat_mean() %&gt;% tab_pivot() #Total Sexo de la persona entrevistada Hombre Mujer Los cuidados y la atención recibida del personal médico 7 18.4 20.6 16.2 8 25.9 27.8 24.1 Top 33.6 30.7 36.4 Bottom 20.6 19.2 21.9 N.S. 1.3 1.5 1.1 N.C. 0.2 0.2 0.3 #Total cases 2557 1256 1301 Mean 7.7 7.7 7.8 Así pues en esta última tabla, hemos combinado algunas de las funcionalidades especiales y avanzadas de expss de forma conjunta y trabajando en la misma dirección. 7.5.1 Gráficos base Dejamos además aquí esta pildora adictiva. ¿Un gráfico? Repetimos la tabla pero la guardamos en una objeto llamada tab. Limpiamos además aquello que no nos interesa. tab &lt;- data %&gt;% tab_cols(&#39;|&#39;=unvr(P31)) %&gt;% tab_cells(&#39;|&#39;=unvr(P901)) %&gt;% tab_net_cells(&#39;Detractores&#39; = 1:6, &#39;Neutrales&#39; = 7:8, &#39;Promotores&#39; = 9:10) %&gt;% tab_stat_cpct(total_row_position=&#39;none&#39;) %&gt;% tab_pivot() tab &lt;- as.data.frame(tab) tab ## row_labels Hombre Mujer ## 1 Detractores 19.1878981 21.9062260 ## 2 Neutrales 48.4076433 40.3535742 ## 3 Promotores 30.7324841 36.3566487 ## 4 N.S. 1.5127389 1.0760953 ## 5 N.C. 0.1592357 0.3074558 Fíjate como hemos limpiado la tabla. Hemos usado un recurso que para gráficos será muy válido, el uso de unvr() que elimina del uso de la variable los textos extra. Del mismo modo con el '|'= hemos anulado cualquier tipo de texto suplementario que se pudiera añadir. Cuando hacemos una tabla y la guardamos, es un objeto etable que ya describimos anteriormente. Como la mayoría de los paquetes gráficos usan dataframes, lo transformamos a eso. Una vez hecho esto, hacemos el gráfico. Podemos elegir diferentes sistemas de gráficos, pero los más habituales e interactivos son highcharter(paquete escrito sobre Highcharts que es el que usa SegmentaNet por defecto) y/o plotly. Como paquete estático, ggplot sería la mejor solución. suppressMessages(library(highcharter, quietly=TRUE)) highchart() %&gt;% hc_xAxis(categories=tab$row_labels) %&gt;% hc_add_series(data=tab, type=&#39;column&#39;, hcaes(x=row_labels, y= Hombre), name=&#39;hombre&#39;) %&gt;% hc_add_series(data=tab, type=&#39;column&#39;, hcaes(x=row_labels, y= Mujer), name=&#39;mujer&#39;) Figure 7.1: Uso de gráfico highcharter 2 Si el gráfico lo hacemos con plotly  suppressMessages(library(plotly, quietly=TRUE)) Grupo &lt;- factor(tab$row_labels, levels=tab$row_labels) plot_ly(tab, x = ~Grupo, y = ~Hombre, type = &#39;bar&#39;, name = &#39;Hombre&#39;) %&gt;% add_trace(y = ~Mujer, name = &#39;Mujer&#39;) %&gt;% layout(yaxis = list(title = &#39;Count&#39;)) ## Warning: `arrange_()` is deprecated as of dplyr 0.7.0. ## Please use `arrange()` instead. ## See vignette(&#39;programming&#39;) for more help ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. Figure 7.2: Uso de gráfico plotly "],["tse07.html", "Capítulo 8 Pruebas inferenciales 8.1 Prueba de dependencia 8.2 Pruebas de diferencias 8.3 Parámetros posibles en las pruebas de significación 8.4 Conclusión", " Capítulo 8 Pruebas inferenciales Cuando trabajamos con tablas de contingencia es muy frecuente que sintamos la necesidad de tener que inferir acerca de la dependencia de las categorías analizadas o de las diferencias entre los grupos analizados. Siempre que nuestras variables cumplan con los requisitos que para ellas cada prueba establece (normalidad, homoscedasticidad, linealidad y en algunos casos independencia), podremos aplicar las pruebas inferenciales típicas con tablas de contingencia en la investigación básica: Chi2 en su variantes de tabla y celda; Pruebas z de contraste proporciones; Prueba t de contraste de medias. Para todas ellasexpss nos da la oportunidad de hacer los cálculos desde el propio script de realización de la tabla y/o desde una instrucción posterior a la realización de la tabla. Pasemos por ello a explicar, no tanto el cometido de estas pruebas, sino el como llevarlas adelante. 8.1 Prueba de dependencia El contraste Chi2 de Pearson es una prueba estadística no paramétrica, que compara las frecuencias realmente obtenidas con las frecuencias esperadas que son las que corresponderían a cada celda o casilla de la tabla si su valor se ajustase a cualquier norma teórica previamente adoptada; en nuestro caso, una distribución proporcional de frecuencias normales. En definitiva, se está calculando un índice acerca de la distancia entre lo real y lo esperado Manzano Arrondo (1995). El valor numérico de esta prueba se obtiene como: fo, serán las frecuencias observadas en el experimento o muestra fe, serán las frecuencias esperadas teóricamente Las frecuencias esperadas se calculan con  fo, serán las frecuencias observadas en el experimento o muestra fe, serán las frecuencias esperadas teóricamente N, es el número de efectivos muestrales Esta prueba se suele utilizar (entre muchas otras posibilidades) para contrastar la hipótesis nula que los resultados obtenidos de una muestra no son significativos con relación a la población total, o bien como prueba de dependencia para comprobar la existencia o no de asociación entre las variables. En este caso, la prueba indica la existencia de asociación pero no la cuantifica Manzano Arrondo (1995). 8.1.1 De una tabla La prueba Chi2 puede hacerse a nivel de tabla, lo que muestra la relación de dependencia entre las categorías. Hagamos una primera aproximación con dos tablas de contingencia muy sencillas, pero que nos mostrarán como se indica que la relación de dependencia existe o no existe. La función tab_last_sig_cases realiza la prueba base de R denominada chisq.test. Nótese el uso de |=unvr() para utilizar la variable sin que se publiquen los texto extra de la misma. data %&gt;% tab_cols(total(), &#39;|&#39;=unvr(P31)) %&gt;% tab_cells(&#39;|&#39;=unvr(P2)) %&gt;% tab_stat_cases() %&gt;% tab_last_sig_cases() %&gt;% tab_pivot() #Total Hombre Mujer En general, el sistema sanitario funciona bastante bien 538.0 277.0 261.0 El sistema sanitario funciona bien, aunque son necesarios al 1247.0 620.0 627.0 El sistema sanitario necesita cambios fundamentales, aunque 637.0 288.0 349.0 Nuestro sistema sanitario está tan mal que necesitaríamos re 120.0 61.0 59.0 N.S. 9.0 6.0 3.0 N.C. 6.0 4.0 2.0 #Chi-squared p-value (warn.) #Total cases 2557.0 1256.0 1301.0 data %&gt;% tab_cols(total(), &#39;|&#39;=unvr(P31)) %&gt;% tab_cells(&#39;|&#39;=unvr(P33)) %&gt;% tab_stat_cases() %&gt;% tab_last_sig_cases() %&gt;% tab_pivot() #Total Hombre Mujer Casado/a 1388.0 677.0 711.0 Soltero/a 817.0 455.0 362.0 Viudo/a 190.0 41.0 149.0 Separado/a 57.0 24.0 33.0 Divorciado/a 97.0 55.0 42.0 N.C. 8.0 4.0 4.0 #Chi-squared p-value &lt;0.05 (warn.) #Total cases 2557.0 1256.0 1301.0 En la primera tabla se muestra la relación entre la variable P31 (sexo) y la P2 (valoración del sistema sanitario). Nótese que en la tabla se ha usado una línea tras el cálculo de los casos con la función tab_last_sig_cases() que indica que se debe realizar la prueba Chi2 a la relación. Esta línea provoca que en la tabla surja una nueva fila sobre el #Total con el texto #Chi-squared p-value que indica que se realiza la prueba al 5% (0,05). Si el resultado es el rechazo de la hipótesis nula de independencia se muestra un &lt;0,05 (warn.), pero si no se puede rechazar la hipótesis nula de independencia sale sólo (warn.) En la tabla no se publica el resultado de la prueba, pero podemos hacerlo siguiendo el formato estándar. table(data$P2, data$P31) ## ## Hombre Mujer ## En general, el sistema sanitario funciona bastante bien 277 261 ## El sistema sanitario funciona bien, aunque son necesarios al 620 627 ## El sistema sanitario necesita cambios fundamentales, aunque 288 349 ## Nuestro sistema sanitario está tan mal que necesitaríamos re 61 59 ## N.S. 6 3 ## N.C. 4 2 chisq.test(table(data$P2, data$P31)) ## ## Pearson&#39;s Chi-squared test ## ## data: table(data$P2, data$P31) ## X-squared = 7.2669, df = 5, p-value = 0.2015 table(data$P33, data$P31) ## ## Hombre Mujer ## Casado/a 677 711 ## Soltero/a 455 362 ## Viudo/a 41 149 ## Separado/a 24 33 ## Divorciado/a 55 42 ## N.C. 4 4 chisq.test(table(data$P33, data$P31)) ## ## Pearson&#39;s Chi-squared test ## ## data: table(data$P33, data$P31) ## X-squared = 75.203, df = 5, p-value = 8.437e-15 Donde se puede observar que para la primera relación, no se puede rechazar la hipótesis de independencia pues el valor de significación es p-value &gt; 0,05 (0.2015); para la segunda relación, sí podemos rechazar la hipótesis nula de independencia, puesto que p-value &lt; 0,05 (por tanto, existe dependencia). 8.1.2 De una celda de una tabla Particularmente de interés es la prueba Chi2 de celda. A diferencia de la anterior, en este caso se realiza la prueba para cada celda de la tabla en particular. La lógica de la misma sería comparar un valor de la tabla (una celda), con el resto de su fila, el resto de su columna, y el resto de la muestra. De este forma, indicamos que valores son significativos en la tabla, aquellos que cabría contemplar con un interés especial. Para obtener la tabla y la subsiguiente prueba se utilizará una nueva función denominada tab_last_sig_cell_chisq() sobre la misma estructura ya conocida de tabla. Nótese que en este caso, para la prueba se requiere utilizar los porcentajes en lugar de los casos, para que el cálculo sea el oportuno. Chi2 es una prueba muy sensible al tamaño de la muestra. data %&gt;% tab_cols(total(), &#39;|&#39;=unvr(P31)) %&gt;% tab_cells(&#39;|&#39;=unvr(P2)) %&gt;% tab_stat_cpct() %&gt;% tab_last_sig_cell_chisq() %&gt;% tab_pivot() #Total Hombre Mujer En general, el sistema sanitario funciona bastante bien 21.0 22.1 20.1 El sistema sanitario funciona bien, aunque son necesarios al 48.8 49.4 48.2 El sistema sanitario necesita cambios fundamentales, aunque 24.9 22.9 &lt; 26.8 &gt; Nuestro sistema sanitario está tan mal que necesitaríamos re 4.7 4.9 4.5 N.S. 0.4 0.5 0.2 N.C. 0.2 0.3 0.2 #Total cases 2557 1256 1301 data %&gt;% tab_cols(total(), &#39;|&#39;=unvr(P31)) %&gt;% tab_cells(&#39;|&#39;=unvr(P33)) %&gt;% tab_stat_cpct() %&gt;% tab_last_sig_cell_chisq() %&gt;% tab_pivot() #Total Hombre Mujer Casado/a 54.3 53.9 54.7 Soltero/a 32.0 36.2 &gt; 27.8 &lt; Viudo/a 7.4 3.3 &lt; 11.5 &gt; Separado/a 2.2 1.9 2.5 Divorciado/a 3.8 4.4 3.2 N.C. 0.3 0.3 0.3 #Total cases 2557 1256 1301 La salida es muy clara. Con los símbolos mayor y menor, se marcan aquellas celdas que son significativamente mayores (&gt;) o menores (&lt;) que lo esperado y por tanto son las que direccionan las relaciones de dependencia que en la tabla se producen. 8.2 Pruebas de diferencias Un conjunto diferentes de pruebas son aquellas cuya hipótesis de partida se basa en determinar si existen diferencias entre los porcentajes (prueba z) o las medias (prueba t) de dos grupos independientes en la muestra extraídos de la misma población. Desarrollamos ambas pruebas en las líneas siguientes. 8.2.1 Porcentajes (prueba z) Asumiendo las hipótesis necesarias para poder trabajar con estadística paramétrica (normalidad, homoscedasticidad, linealidad y en algunos casos independencia), la función tab_last_sig_cpct realiza z-test entre columnas de porcentajes derivadas de la aplicación de tab_stat_cpct. Los resultados son calculados con la misma fórmula que con la función base de R prop.test y sin la corrección de continuidad. Obsérvese la diferencia de concepto; mientras que la prueba Chi2 de celda realiza la prueba comparando con el marginal total, la prueba z realiza esa comparación entre los grupos formados por las columnas, a los que se suele llamar perfiles. De esta forma considera la independencia de los grupos muestrales entre sí. Para utilizar esta funcionalidad el script sería el siguiente: data %&gt;% tab_cols(total(), &#39;SEXO&#39;=unvr(P31)) %&gt;% tab_cells(&#39;|&#39;=unvr(P2)) %&gt;% tab_stat_cpct() %&gt;% tab_last_sig_cpct() %&gt;% tab_pivot() #Total SEXO Hombre Mujer A B En general, el sistema sanitario funciona bastante bien 21.0 22.1 20.1 El sistema sanitario funciona bien, aunque son necesarios al 48.8 49.4 48.2 El sistema sanitario necesita cambios fundamentales, aunque 24.9 22.9 26.8 A Nuestro sistema sanitario está tan mal que necesitaríamos re 4.7 4.9 4.5 N.S. 0.4 0.5 0.2 N.C. 0.2 0.3 0.2 #Total cases 2557 1256 1301 data %&gt;% tab_cols(total(), &#39;SEXO&#39;=unvr(P31)) %&gt;% tab_cells(&#39;|&#39;=unvr(P33)) %&gt;% tab_stat_cpct() %&gt;% tab_last_sig_cpct() %&gt;% tab_pivot() #Total SEXO Hombre Mujer A B Casado/a 54.3 53.9 54.7 Soltero/a 32.0 36.2 B 27.8 Viudo/a 7.4 3.3 11.5 A Separado/a 2.2 1.9 2.5 Divorciado/a 3.8 4.4 3.2 N.C. 0.3 0.3 0.3 #Total cases 2557 1256 1301 En nuestro caso, los resultados son muy semejantes a los vistos con Chi2 de celda, porque la variable elegida para las columnas es dicotómica, es decir, con sólo dos opciones de respuesta, exhaustivas y mutuamente excluyentes. No sería así si la variable de columnas presentara más de 2 perfiles. La lectura de esta prueba es la siguiente. El porcentaje de casos en en el grupo B (mujeres) de la tabla 1, es significativamente más elevado que el de hombres, determinándose esta diferencia con una significación del 5%. En el caso de la tabla 2, el porcentaje de hombres solteros es significativamente diferente del porcentaje de mujeres solteras. Del mismo modo y a la inversa el porcentaje de mujeres viudas entrevistadas en la muestra es significativamente mayor que el de hombres. Por tanto, creemos que queda claro el funcionamiento de la prueba. Se etiquetan las columnas y se muestra la letra de la columna con la que se presentan diferencias positivas junto al valor porcentual. La prueba se realiza para cada celda, pero siempre comparando con las celdas que tiene a su derecha o izquierda en la misma fila (no con el total). 8.2.2 Medias (prueba t) Al igual que en el apartado anterior el objetivo es determinar si existen o no diferencias entre los grupos que se están testando, teniendo como hipótesis nula que las medias de los grupos son iguales. En nuestro ejemplo, hemos tomado la de auto clasificación ideológica (recodificando las posiciones de 1 a 10, izquierda a derecha respectivamente) creando grupos de izquierda, centro y derecha. Sobre esta tabla que calcula las medias, se aplica el estadístico tab_stat_mean_sd_n()que contiene todos los datos requeridos para el cálculo del valor t y se le indica que requerimos el test con tab_last_sig_means(). Se asume que los grupos son independientes, que existe normalidad y que las varianzas de los grupos son iguales. data %&gt;% tab_cols(total(), P29=recode(P29, &#39;Izquierda&#39; = 1:4 ~1, &#39;Centro&#39; = 5:6 ~2, &#39;Derecha&#39; = 7:10 ~ 3, TRUE ~ NA)) %&gt;% tab_cells(P3=na_if(P3, gt(10))) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_last_sig_means() %&gt;% tab_pivot() #Total P29 Izquierda Centro Derecha A B C Satisfacción Mean 6.8 6.7 6.8 7.1 A B Std. dev. 1.9 1.9 1.8 2.0 Unw. valid N 2542.0 770.0 750.0 348.0 Se puede observar que la salida es igual a la de la prueba Z. Se rotulan las columnas con las letras A, B  y las que sean necesarias, y posteriormente se muestra (por defecto) la letra de la columna con la que la media de la columna en la que se ubica la media presenta diferencias positivas (es mayor). Podemos por tanto observar, que en la población de la que se ha extraído la muestra, se puede afirmar que la media de satisfacción con el funcionamiento del sistema sanitario español es más alta en los individuos cuya auto clasificación ideológica es del grupo de derecha (C), que en la izquierda (A) y en el centro (B). No entramos a valorar si la distribución de grupos es la correcta o no, en cuanto al significado general. Se ha hecho una distribución acorde al significado de los números en sí mismos. Existen ocasiones en las que esta prueba, se requiere publicar para un conjunto de ítems que forman parte de una misma batería. En estos casos, no es tan interesante publicar las desviaciones y las bases, por lo que podemos formular de esta forma el script. data %&gt;% tab_cols(total(), P29=recode(P29, &#39;Izquierda&#39; = 1:4 ~1, &#39;Centro&#39; = 5:6 ~2, &#39;Derecha&#39; = 7:10 ~ 3, TRUE ~ NA)) %&gt;% tab_cells(P901=na_if(P901, gt(10))) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_last_sig_means(keep=&#39;means&#39;) %&gt;% tab_cells(P902=na_if(P902, gt(10))) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_last_sig_means(keep=&#39;means&#39;) %&gt;% tab_cells(P903=na_if(P903, gt(10))) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_last_sig_means(keep=&#39;means&#39;) %&gt;% tab_cells(P904=na_if(P904, gt(10))) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_last_sig_means(keep=&#39;means&#39;) %&gt;% tab_cells(P905=na_if(P905, gt(10))) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_last_sig_means(keep=&#39;means&#39;) %&gt;% tab_cells(P906=na_if(P906, gt(10))) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_last_sig_means(keep=&#39;means&#39;) %&gt;% tab_cells(P907=na_if(P907, gt(10))) %&gt;% tab_stat_mean_sd_n() %&gt;% tab_last_sig_means(keep=&#39;means&#39;) %&gt;% tab_pivot() #Total P29 Izquierda Centro Derecha A B C Los cuidados y la atención recibida del personal médico Mean 7.7 7.7 7.8 7.9 Los cuidados y la atención recibida del personal de enfermería Mean 7.8 7.8 7.7 7.9 La confianza y seguridad que transmite el personal médico Mean 7.8 7.7 7.8 8.0 A La confianza y seguridad que transmite el personal de enfermería Mean 7.8 7.7 7.7 8.0 A B El tiempo dedicado por el médico o la médica a cada enfermo o enferma Mean 7.1 6.9 7.0 7.2 El conocimiento del historial y seguimiento de los problemas de salud de cada usuario o usuaria Mean 7.5 7.4 7.4 7.7 A B La información recibida sobre su problema de salud Mean 7.5 7.4 7.5 7.8 A B Se puede observar que la instrucción keep='means' lo que ha conseguido es eliminar la publicación de la desviación y la media del cuadro presentado. De este modo el resultado es más compacto y da una visión general de la batería de ítems 8.3 Parámetros posibles en las pruebas de significación De manera conjunta exponemos aquí diferentes parámetros que modifican el comportamiento por defecto de las cuatro pruebas anteriormente vistas. Algunos son de uso en todas ellas y otros específicos de alguna de las pruebas. sig_level, numérico; nivel de significación, por defecto es igual a 0.05. min_base, numérico; el test de significación se realizará si ambas columnas tienes bases mayores o iguales al valor determinado que por defecto es 2. delta_cpct, numérico; delta mínimo entre el porcentaje para el que marcamos diferencias significativas (en puntos porcentuales); de forma predeterminada, es igual a cero. Tenga en cuenta que, por ejemplo, para una diferencia mínima de 5 por ciento de puntos, delta_cpct debe ser igual a 5, no 0.05. delta_means, numérico; delta mínimo entre medias para las que marcamos diferencias significativas: por defecto es igual a cero. correct, lógico (TRUE o FALSE), indica si aplicar corrección de continuidad al calcular el estadístico Chi2 de prueba para tablas de 2 por 2. Solo para significance_cases y significance_cell_chisq. Para más detalles ver chisq.test. TRUE por defecto. compare_type tipo de comparación por columnas. Por defecto, es subtabla (variable por variable). otras posibilidades son \"first_column\", \"adjusted_first_column\" y \"previous_column\"; podemos realizar varios test simultáneamente. bonferroni lógico; FALSE por defecto; uso del ajuste de Bonferroni por cada fila. subtable_marks, carácter; una de las siguientes opciones: \"greater\", \"both\" or \"less\"; por defecto se marcan sólo valores cuya significación sea mayor (\"greater\") que alguna otra columna. Para significance_cell_chisq por defecto es \"both\". podemos modificar este comportamiento usando las otras alternativas. inequality_sign logical. FALSE if subtable_marks is less or greater. Should we show &gt; or &lt; before significance marks of subtable comparisons. sig_labels character vector labels for marking differences between columns of subtable. sig_labels_previous_column a character vector with two elements. Labels for marking a difference with the previous column. First mark means lower (by default it is v) and the second means greater (^). sig_labels_first_column a character vector with two elements. Labels for marking a difference with the first column of the table. First mark means lower (by default it is -) and the second means greater (+). sig_labels_chisq a character vector with two labels for marking a difference with row margin of the table. First mark means lower (by default it is &lt;) and the second means greater (&gt;). Only for significance_cell_chisq. keep, carácter. Una o más de las siguientes \"percent\", \"cases\", \"means\", \"bases\", \"sd\" o \"none\". Este argumento determina qué estadísticos permanecerán en la tabla después del marcado de significación. row_margin, carácter. Uno de los valores \"auto\" (predeterminado), \"sum_row\" o \"first_column\". Si es \"auto\", tratamos de encontrar la columna total en la subtabla por total_column_marker. Si la búsqueda falla, usamos la suma de cada fila como total de filas. Con la opción \"sum_row\" siempre sumamos cada fila para obtener margen. Tenga en cuenta que en este caso el resultado de las variables de respuesta múltiple en la cabecera puede ser incorrecta. Con la opción \"first_column\" usamos la tabla primera columna como margen de fila para todas las subtablas. En este caso, el resultado de las subtablas con bases incompletas puede ser incorrecto. Solo para significance_cell_chisq. total_marker, carácter. Total de fila marcado en la tabla. \" # \" por defecto. total_row, entero/carácter. En el caso de varios totales por subtabla, es un número o nombre de fila total para el cálculo de significación. digits, un número entero que indica cuántos dígitos después del separador decimal se mostrarán en la tabla final. na_as_zero, lógico; FALSE por defecto. ¿Deberíamos tratar a NA como cero casos? var_equal, lógico; variable que indica si se deben tratar las dos varianzas como iguales. Para más detalles ver t.test. mode, carácter; \"replace\" (default) o \"append\". En el primer caso, el resultado anterior en la secuencia del cálculo de la tabla se reemplazará con el resultado de la prueba de significación. En el segundo caso, el resultado de la prueba de significación se agregará a la secuencia del cálculo de la tabla. label, carácter; etiqueta para la estadística en tab_*. Ignorado si el modo es igual a replace. total_column_marker, carácter; marca para la columna de totales en las subtablas. # por defecto. x table (class etable): result of cro_cpct with proportions and bases for significance_cpct, result of cro_mean_sd_n with means, standard deviations and valid N for significance_means, and result of cro_cases with counts and bases for significance_cases. cases_matrix, matriz numérica con recuentos de tamaño filas*columnas. row_base, vector de números con las bases de fila. col_base, vector de números con las bases de columna. total_base, número con la base total. 8.3.1 Algunos ejemplos de uso de los parámetros Cambio del nivel de significación de la prueba y eliminación de las filas con las frecuencias, entre otros data %&gt;% tab_cols(total(), &#39;|&#39;=unvr(P31)) %&gt;% tab_cells(&#39;|&#39;=unvr(P33)) %&gt;% tab_stat_cases() %&gt;% tab_last_sig_cases(sig_level = 0.01, correct = TRUE, keep=&#39;bases&#39;, mode=&#39;replace&#39;, label=&#39;***&#39;) %&gt;% tab_pivot() #Total Hombre Mujer #Chi-squared p-value &lt;0.01 (warn.) #Total cases 2557.0 1256.0 1301.0 8.4 Conclusión Hasta aquí llegamos. Hemos presentado de forma muy breve y simplificada como podemos aprovechar toda la potencia de expss en nuestros scripts. Lo importante es practicar y practicar. No dejes de acudir a las viñetas de ayuda de Gregory Demin acerca de como usar el paquete y como generar nuevas tablas. Nosotros tan sólo hemos sentado las bases. Combinando las tablas con lenguaje R se puede llegar a conseguir casi todo. manual PDF de EXPSS material de ayuda, ejemplos uso de etiquetas en R Bibliografía "],["tse08.html", "Capítulo 9 Visualización gráfica 9.1 highcharteR, introducción 9.2 Mi primer gráfico 9.3 Gráfico de barras 9.4 Gráfico de columna 9.5 Diagramas de secciones 9.6 Gráfico de línea 9.7 Gráficos de columnas / barras con apilamiento 9.8 Gráfico de área 9.9 Gráfico de puntos / scatterplot 9.10 Histograma o gráfico de densidad 9.11 Gráficos indicadores 9.12 Gráfico / boxplot 9.13 Gráfico de barras de error 9.14 Gráficos de transiciones 9.15 Conclusión", " Capítulo 9 Visualización gráfica Una de las cuestiones importantes cuando usamos scripting avanzado (R) en SegmentaNet es que en muchas ocasiones no podemos acudir a los gráficos estandarizados. Aun disponiendo de la posibilidad de realizar gráficos de tablas obtenidas con expss en R, mediante la utilización del análisis con scripting avanzado (consola), es deseable conocer que ha sido desarrollado un wrapper del software highcharts para ser utilizado en R y denominado highcharter. En este capítulo vamos a enseñarte como aprovechar toda la potencia de Highcharts dentro de SegmentaNet, utilizando como vehículo de propulsión el paquete highcharter desarrollado por (Kunst 2020). Sí, probablemente estés pensando que los gráficos los hace de forma muy sencilla el propio SegmentaNet, pero eso sucederá siempre y cuando le proporciones la información como el gráfico necesita. Sí, ya sé que también tienes un editor manual de gráficos en SegmentaNet, pero quizá te pueda ayudar el poder hacer un gráfico desde script. Quizá ya nunca quieras hacerlo de la otra forma pues tendrás el control total de los gráficos que hace SegmentaNet, e incluso aplicar propiedades que no está accesibles desde el propio SegmentaNet. Este último punto lo dejamos para el final. 9.1 highcharteR, introducción El paquete highcharter es un contenedor para la biblioteca Highcharts que incluye funciones de acceso directo para trazar objetos gráficos de R. Es una biblioteca de gráficos que ofrece numerosos tipos de gráficos con una sintaxis de configuración muy simple y repetitiva. Suponemos que ya estás acostumbrado a trabajar con R, por lo que no te resultará complicado seguir los pasos aquí indicados. Este documento fundamentalmente se ha dedicado a trabajar con tablas cruzadas (o mejor con los dataframe creados con esas tablas), ese elemento que tanta productividad produce y que tan claras deja las visualizaciones; sin embargo la mayoría de librerías de gráficos trabajan con dataframe, por lo que deberemos hacer una simplificación de la tabla para trabajar con ella de forma adecuada. No sería necesario, pero como digo te ayudará a ver con otros ojos la simplicidad de highcharter. Comenzaremos trabajando con la base de la librería y en el desarrollo del capítulo indicaremos como trabajar con tablas cruzadas. Lo primero que debemos saber, es que hay unos nombres de campo (por defecto) en el dataframe cuya presencia facilita enormemente el trabajo con los gráficos. Mira esta tabla de datos. En esta tabla son muy importantes los nombres de los campos, porque su existencia hace que sin apenas código, el gráfico ya visualiza de acuerdo a nuestra necesidad. x y z low high value name color from to weight 0 1.6 -34.0 -6.0 9.2 1 lemon #d35400 lemon olive 1 1 11.0 -23.0 6.7 15.3 10 nut #2980b9 lemon guava 1 2 20.4 6.8 2.8 38.0 19 olive #2ecc71 lemon fig 1 3 22.1 32.3 19.4 24.8 21 guava #f1c40f nut olive 1 4 15.4 27.7 12.1 18.7 14 fig #2c3e50 olive pear 2 5 7.4 3.2 -11.8 26.6 6 pear #7f8c8d guava pear 2 A saber  x, que contiene la secuencia de datos y, que contiene el dato que habitualmente representaremos en el eje de las Y (ordenadas) z, dimensiona el valor de y cuando se quieren usar tres dimensiones de representación (por ejemplo cuando queremos que en un scatter la burbuja sea tan grande como una tercera variable) low, valor más bajo para la categoría high, valor más alto para la categoría value, valor de la categoría name, que contiene lo nombres o textos de las categorías; suele ser lo que queremos que aparezca en el eje de las X (abscisas) color, código del color en hexadecimal que modificará el color por defecto de la serie (puede ser también el nombre del color) from, importante en gráficos especiales de tipo organización o donde hay una relación desde to, igual al anterior, importante en gráficos especiales de tipo organización o donde hay una relación hasta weight, utilizado en algunos gráficos a los que nos referiremos después. Debemos saber que highcharteRnos permite utilizar dos tipos diferentes de funciones que a continuación explicamos, auqnue nos centramos en la primera de ellas. La segunda es una forma de acortar la primera. highchart() hchart() 9.1.1 highchart() Esta función crea un gráfico highchart usando un widget. El widget creado se puede representar en páginas HTML generadas a partir de rmarkdown y con características de interactividad. Si estás familiarizado con el paquete ggplot2, es una función similar a ggplot() del paquete donde se define un objeto ggplot base sobre el cual se pueden agregar más capas geométricas. De manera similar, una vez que se define la función highchart(), se pueden agregar más elementos highchart encima de ella, como si fueran capas superpuestas. 9.1.2 hchart() Por otro lado, hchart () es una función genérica para dibujar diferentes gráficos sobre la marcha. El gráfico resultante es un objeto highchart, por lo que puede seguir modificando con la API implícita. Si estás familiarizado con ggplot2, esta función es similar a qplot(). Comencemos nuestro viaje de visualización interactiva con los diseño más sencillos. 9.2 Mi primer gráfico Para trabajar con los gráficos, utilizaremos la siguiente tabla de datos, muy sencilla, propuesta por el autor del paquete, que además contiene los nombres de campo estandarizados que nos van a ayudar a de forma muy sencilla a generar nuestras visualizaciones. 9.3 Gráfico de barras Un diagrama de barras (o columnas) muestra la relación entre una variable numérica (y) y una categórica (name). Cada entidad de la variable categórica se representa como una barra. El tamaño de la barra representa su valor numérico. A veces se describe como una forma aburrida de visualizar información. Sin embargo, probablemente sea la forma más eficaz de mostrar este tipo de datos. Vamos a mostrar las dos formas de hacer este gráfico y entenderás la información que te aportábamos en la descripción anterior de las funciones posibles para hacer un gráfico. require(highcharter) # solicitamos la carga de highcharter si no lo está ya df1 &lt;- select(df, name, y, color) # seleccionamos las columnas name e y, por un motivo que más adelante explicamos highchart() %&gt;% hc_chart(type = &#39;bar&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1) ¿Por qué hemos seleccionado estos tres campos? Ya hemos hablado de la importancia del nombre de los campos en highcharter. El gráfico de barras que es un estándar, es transformado a un gráfico de barras low-high si se localizan estos nombres de campo, low y high en el dataframe de trabajo, y el dataframe original df los tenía. Por tanto si repetimos este gráfico, pero con el dataframe original con esos dos campos, veremos que variación se produce. highchart() %&gt;% hc_chart(type = &#39;bar&#39;) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_add_series(df) La barra no se traza completa sino que se traza con origen en el valor más bajo (low), y con final en el valor más alto (high). Sin embargo si acercas el ratón a una barra, verás que el valor listado se corresponde con el campo y del dataframe. Vamos a realizar unas pequeñas variaciones muy habituales en los gráficos. 9.3.1 Cambiar el nombre de la serie de datos La primera modificación sería añadir el nombre de la serie al gráfico  highchart() %&gt;% hc_chart(type = &#39;bar&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;) Podemos observar, como en ángulo inferior derecho de la ventana del gráfico aparece la palabra fruits que hemos escrito como nombre del conjunto de datos, que en realidad es una única serie. 9.3.2 Añadir créditos al gráfico Añadir un pie de gráfico con créditos del creador del mismo. highchart() %&gt;% hc_chart(type = &#39;bar&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) Ver ángulo inferior derecho, justo debajo del nombre de la serie. Posibilidad de hacer clic y llegar hasta la URL indicada. 9.3.3 Añadir el valor del dato al elemento (datalabels) highchart() %&gt;% hc_chart(type = &#39;bar&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) 9.3.4 Guardar y exportar el gráfico En ocasiones es necesario dar la oportunidad al usuario del gráfico de poder guardarlo como imagen o guardarlo como tabla de EXCEL o fichero de texto separado por , (CSV). highchart() %&gt;% hc_chart(type = &#39;bar&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) 9.3.5 API de Highcharts, toda la potencia de los gráficos La pregunta que ahora nos deberíamos estar haciendo es ¿como puedo yo saber que debo usar hc_credits(), o hc_exporting() o dataLabels(list=())? Para eso tenemos lo que se llama la API de la librería de gráficos. Ahora entenderemos mejor el apartado de presentación cuando decíamos que highcharteres un wrapper de la librería Highcharts. Si visitamos el sitio web de la api de highcharts podemos ver que todas las opciones que se pueden usar en los gráficos están documentadas. Si a ello añadimos el sitio demo de esta marca podemos ver todo lo que se puede hacer. Te recomiendo la lectura del post de Danton Noriega acerca de como usar la API para saber construir nuestros gráficos en de highchart en R, en especial la parte en la que refiere a este punto que estamos hablando (Highcharts API and highcharter functions). Tras la lectura de ese post te darás cuenta de que en tus manos de analista de datos, tienes un auténtico cañón de magníficas visualizaciones. Pero vayamos poco a poco y continuemos con nuestros ejemplos de gráficos. 9.4 Gráfico de columna Es un gráfico idéntico al anterior, pero con la barra vertical en lugar de horizontal. Mantenemos la última vista básica con los elementos añadidos de exportación, créditos y mostrado de valores de aquí en adelante. highchart() %&gt;% hc_chart(type = &#39;column&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Obsérvese que en el gráfico lo único que hemos hecho ha sido modificar el tipo de gráfico de bara column. Añadamos ahora perspectiva al gráfico, incluyendo la lista de opciones de 3D. highchart() %&gt;% hc_chart(type = &#39;column&#39;, options3d = list(enabled = TRUE, beta = 45, alpha = 15)) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) ### Variación de columna a pirámide Y si lo presentamos en forma de pirámide  highchart() %&gt;% hc_chart(type = &#39;columnpyramid&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;,showInLegend = FALSE, dataLabels = list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) ### Variación de columna a lollipop Y si lo presentamos en forma de lollipop, debemos variar al dataframe al completo, porque este gráfico muy parecido a la variación de rango, requiere del low-high. highchart() %&gt;% hc_chart(type = &#39;dumbbell&#39;) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_add_series(df, name=&#39;Fruits&#39;,showInLegend = FALSE, dataLabels = list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) highchart() %&gt;% hc_chart(type = &#39;dumbbell&#39;, inverted=TRUE) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_add_series(df, name=&#39;Fruits&#39;,showInLegend = FALSE, dataLabels = list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) 9.4.1 Gráficos polares Existe otra forma de visualizar el gráfico que nos va a gustar mucho, porque se ve en pocas ocasiones. highchart() %&gt;% hc_chart(type = &#39;bar&#39;, polar=TRUE) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Nótese que se ha añadido el modificador polar=TRUE Una buena vista, espectacular pero poco efectiva. Desde el propio script, sin embargo se puede añadir una mínima opción que mejoraría esta salida. highchart() %&gt;% hc_chart(type = &#39;bar&#39;, polar=TRUE) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) %&gt;% hc_pane(endAngle=270) Esta nueva función hc_pane() hace que el círculo termine en el ángulo 270 (de 360), de forma que las etiquetas se leen mejor. Pero no es una visualización fácil, visualmente atractiva, pero difícil de leer e intepretar. 9.5 Diagramas de secciones 9.5.1 Tarta / pie chart Si hay algún gráfico tan o más famoso que el de barras o el de columnas, ese es el gráfico de tarta. df$sliced &lt;- c(0,1,0,0,1,0) #añadimos el campo sliced highchart() %&gt;% hc_title(text = &#39;Fruits pie&#39;) %&gt;% hc_subtitle(text = &#39;My favourite fruits&#39;) %&gt;% hc_chart(type = &#39;pie&#39;, polar = FALSE, inverted = FALSE) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_add_series(df,name = &quot;Fruits&quot;, showInLegend = TRUE) df &lt;- select(df, -sliced) #eliminamos el campo sliced Además de haberle añadido un título y un subtítulo este gráfico presenta un nuevo elemento fundamental: el modificador showInLegend=TRUE que nos permite mostrar una leyenda con las diferentes frutas y sus colores. Además, en el script hemos comenzado por añadir un nuevo campo a la tabla df, denominado slicedque ya puedes ver su efecto, separa del centro (desgaja) una sección de la tarta. En este caso ha sucedido para la fruta en segundo lugar (nut) y para la que está en quinto lugar (fig). 9.5.2 Anillo / doughnut Y si queremos convertir este gráfico en un anillo o doughnut utilizaremos el modificador innerSize='75%' en la función hc_add_series(). Este modificador traza un círculo desde el baricentro del diagrama hasta el porcentaje indicado dejando espacio central en blanco. El gráfico puede tomar diferente aspecto según ese porcentaje indicado. highchart() %&gt;% hc_title(text = &#39;Fruits pie&#39;) %&gt;% hc_subtitle(text = &#39;My favourite fruits&#39;) %&gt;% hc_chart(type = &#39;pie&#39;, polar = FALSE, inverted = FALSE) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_add_series(df,name = &quot;Fruits&quot;, showInLegend = TRUE, innerSize=&#39;75%&#39; ) o también, cambiando el radio inferior de vaciado  highchart() %&gt;% hc_title(text = &#39;Fruits pie&#39;) %&gt;% hc_subtitle(text = &#39;My favourite fruits&#39;) %&gt;% hc_chart(type = &#39;pie&#39;, polar = FALSE, inverted = FALSE) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_add_series(df,name = &quot;Fruits&quot;, showInLegend = TRUE, innerSize=&#39;33%&#39;) 9.5.3 Funnel Una variante para gráficos de un único campo es el funnel. 9.5.4 Pirámide Una nueva variante para un gráfico de una sola variable. el tipo pyramid. 9.6 Gráfico de línea Un nuevo pero tradicional modelo, el gráfico de línea. Vamos a aprovechar para no ser demasiado repetitivos para añadir una nueva serie de valores; recordemos la tabla de datos inicial. x y z low high value name color from to weight 0 1.6 -34.0 -6.0 9.2 1 lemon #d35400 lemon olive 1 1 11.0 -23.0 6.7 15.3 10 nut #2980b9 lemon guava 1 2 20.4 6.8 2.8 38.0 19 olive #2ecc71 lemon fig 1 3 22.1 32.3 19.4 24.8 21 guava #f1c40f nut olive 1 4 15.4 27.7 12.1 18.7 14 fig #2c3e50 olive pear 2 5 7.4 3.2 -11.8 26.6 6 pear #7f8c8d guava pear 2 Vamos a utilizar z, como si fuera una nueva serie de valores. Es decir como si quisiéramos representar en el diagrama dos conjuntos de valores. Primero lo mostramos como hasta ahora, con una sola serie df1 &lt;- select(df, name, y, z, color) # seleccionamos las columnas name, y y z highchart() %&gt;% hc_chart(type = &#39;line&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Para ahora añadir la nueva serie. Nótese la variación en el modificador hc_add_series()donde ahora hay dos líneas, como si de dos capas se tratara. highchart() %&gt;% hc_chart(type = &#39;line&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1, name=&#39;Fruits - serie 1&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_add_series(df1$z, name=&#39;Fruits - serie 2&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Quisiera hacer notar que simplemente hemos añadido una nueva serie que se contiene en la columna denominada z de df1 (df1$z) y no hemos modificado la anterior serie que por defecto era el campo y. Creo que sería mucho más limpio y ordenado el escribir este mismo gráfico así. highchart() %&gt;% hc_chart(type = &#39;line&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Fruits - serie 1&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_add_series(df1$z, name=&#39;Fruits - serie 2&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) De este modo, identificamos que es cada una de las series yy z, obteniendo idéntico resultado pero quedando más clara la sintaxis de cada una de las series introducidas. 9.6.0.1 Suavizado de la línea En muchas ocasiones es interesante suavizar la línea. Para ello highcharts tiene un modificador del tipo de gráfico denominado spline. highchart() %&gt;% hc_chart(type = &#39;spline&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Fruits - serie 1&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_add_series(df1$z, name=&#39;Fruits - serie 2&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Nótese el suavizado de la curva. Y ha llegado un momento de hacer algo no habitual, pero que sí puede darte ideas de futuro. highchart() %&gt;% hc_chart(type = &#39;line&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Fruits - serie 1&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_add_series(df1$z, type=&#39;column&#39;, name=&#39;Fruits - serie 2&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Vaya sorpresón y qué sencillo, ¿verdad? Hemos combinado línea con columna (no todas las combinaciones son posibles). Además como z tenía valores negativos, las barras negativas se muestran muy claramente. ¿Y si polarizamos este gráfico? highchart() %&gt;% hc_chart(type = &#39;line&#39;, polar=TRUE) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Fruits - serie 1&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_add_series(df1$z, type=&#39;column&#39;, name=&#39;Fruits - serie 2&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) ¡Nada mal! aunque es posible que no combinando el tipo de representación en las series, la visualización sea más clara, en lo que se denomina gráfico spider que es muy utilizado para las baterías o tablas de ítems en nuestras encuestas. Y ya puestos, añadimos un toque de color a nuestro gráfico. Analiza tú mismo los modificadores que cambian. highchart() %&gt;% hc_chart(type = &#39;line&#39;, polar=TRUE, backgroundColor=&#39;#E2E2E2&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Fruits - serie 1&#39;, dataLabels=list(enabled=TRUE), color=&#39;#eb6909&#39;) %&gt;% hc_add_series(df1$z, name=&#39;Fruits - serie 2&#39;, dataLabels=list(enabled=TRUE), color=&#39;teal&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) 9.7 Gráficos de columnas / barras con apilamiento Volvamos la vista un poco atrás, y ahora que tenemos dos series, vamos a jugar un poco más el gráfico o más específicamente con las columnas (o barras). Vamos a realizar los apilamientos (no se pueden hacer lógicamente con los gráficos de tarta). Recuperamos nuestro gráfico de columnas, pero lo hacemos ahora con las dos series, pero ahora, para que los dos valores (y,z) sean positivos, vamos a trabajar con el campo denominado yy el campo denominado value. df1 &lt;- select(df, name, y, z, value, color) # seleccionamos las columnas name, y y value highchart() %&gt;% hc_chart(type = &#39;column&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE), color=&#39;#EB6909&#39;) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE), color=&#39;#C2C2C2&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Nótese que hemos añadido una novedad y es la asignación a la serie del color que nos gusta para ella, mediente el modificador color en la opción hc_add_series(). Procedamos con el apilamiento. highchart() %&gt;% hc_chart(type = &#39;column&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE), color=&#39;#EB6909&#39;, stacking=&#39;normal&#39;) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE), color=&#39;#C2C2C2&#39;, stacking=&#39;normal&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Nótese que en ambas series, se ha introducido el modificador stacking='normal'que ocasiona ese ajuste en las series. Podemos combinar series con apilamiento y series sin apilamiento (agrupaciones de categorías para verlas conjuntamente). highchart() %&gt;% hc_chart(type = &#39;column&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE), color=&#39;#EB6909&#39;, stacking=&#39;normal&#39;) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE), color=&#39;#C2C2C2&#39;, stacking=&#39;normal&#39;) %&gt;% hc_add_series(df1$z, name=&#39;Año 2020&#39;, dataLabels=list(enabled=TRUE), color=&#39;#020202&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Y por último, el apilamiento puede ser normal o puede ser percent donde la representación (que no el valor mostrado) se calcula en base 100. Nótese que todas las columnas son igual de altas y nótese que nuevamente z se mantiene sin apilamiento. highchart() %&gt;% hc_chart(type = &#39;column&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE), color=&#39;#EB6909&#39;, stacking=&#39;percent&#39;) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE), color=&#39;#C2C2C2&#39;, stacking=&#39;percent&#39;) %&gt;% hc_add_series(df1$z, name=&#39;Año 2020&#39;, dataLabels=list(enabled=TRUE), color=&#39;#020202&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Por último, apilemos todas  highchart() %&gt;% hc_chart(type = &#39;column&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE), color=&#39;#EB6909&#39;, stacking=&#39;percent&#39;) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE), color=&#39;#C2C2C2&#39;, stacking=&#39;percent&#39;) %&gt;% hc_add_series(df1$z, name=&#39;Año 2020&#39;, dataLabels=list(enabled=TRUE), color=&#39;#020202&#39;, stacking=&#39;percent&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Y pongamos el gráfico en estilo polar. highchart() %&gt;% hc_chart(type = &#39;column&#39;, polar=&#39;TRUE&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE), color=&#39;#EB6909&#39;, stacking=&#39;percent&#39;) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE), color=&#39;#C2C2C2&#39;, stacking=&#39;percent&#39;) %&gt;% hc_add_series(df1$z, name=&#39;Año 2020&#39;, dataLabels=list(enabled=TRUE), color=&#39;#020202&#39;, stacking=&#39;percent&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) 9.8 Gráfico de área Volvamos a nuestras dos series (y, value) para presentar ahora una nueva visualización, el gráfico de área. Esta es una variación del gráfico de línea donde se dibujan éstas pero con la superficie bajo las líneas con el color indicado, mostrándose de esta forma. highchart() %&gt;% hc_chart(type = &#39;area&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE), color=&#39;#EB6909&#39;) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE), color=&#39;#C2C2C2&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Nótese la superposición de una y otra. Normalmente ese gráfico se usa para representar mediciones en las que una siempre está por encima de la otra (como aquí sucede), pero siempre pensando que las áreas de intersección van a combinar el color. Podemos también apilar los valores directos. highchart() %&gt;% hc_chart(type = &#39;area&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE), color=&#39;#EB6909&#39;, stacking=&#39;normal&#39;) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE), color=&#39;#C2C2C2&#39;, stacking=&#39;normal&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) O mostrar las áreas con base 100. highchart() %&gt;% hc_chart(type = &#39;area&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE), color=&#39;#EB6909&#39;, stacking=&#39;percent&#39;) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE), color=&#39;#C2C2C2&#39;, stacking=&#39;percent&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) 9.9 Gráfico de puntos / scatterplot Variación de los anteriores vamos a presentar sus dos versiones. La versión llamemos natural sería representar los puntos (igual que en el gráfico de línea) pero sin dibujar el trazo que los une. highchart() %&gt;% hc_chart(type = &#39;scatter&#39;) %&gt;% hc_xAxis(categories = df1$name) %&gt;% hc_add_series(df1$y, name=&#39;Año 1900&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_add_series(df1$value, name=&#39;Año 2000&#39;, dataLabels=list(enabled=TRUE)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Sin embargo, cuando uno piensa en un scatterplot, lo que piensa es en un diagrama de dispersión o mapa cartesiano donde se presentan los puntos con sus coordenadas en x y también en y. Un diagrama de dispersión muestra la relación entre 2 variables numéricas. Para cada punto de datos, el valor de su primera variable se representa en el eje X, el segundo en el eje Y. Como no disponemos datos para un buen scatterplot, vamos a construirnos un banco de datos (aleatorio) y trabajamos con él. #==================== construcción del dataframe set.seed(311265) # para que la aleatoriedad sea siempre la misma, fijamos su semilla de aleatorización dfextra &lt;- data.frame(mat=sample(1:100, 400, replace=TRUE), # un valor de un campo X, por ejemplo puntuación en habilidad en matemáticas bio=sample(1:100, 400, replace=TRUE), # un valor de un campo y, por ejemplo puntuación en habilidad en biología glob=sample(50:100, 400, replace=TRUE), # un valor z de peso global de adecuación al puesto grp=sample(1:3, 400, replace=TRUE) # grupo de pertenencia (tres grupos, 1, 2 y 3) ) #================== mostramos extracto del data frame knitr::kable(head(dfextra)) # mostramos breve extracto de la tabla creada mat bio glob grp 72 80 76 3 6 49 85 3 76 47 55 2 50 42 98 2 65 77 69 2 34 8 97 3 Y vamos con el gráfico  hchart(dfextra, &#39;scatter&#39;, hcaes(x=mat, y=bio, group=grp)) Puedes observar que para este tipo de gráfico hemos optado por la forma acotada; esto es debido a que la forma de ofrecerle los datos es más simple, sin embargo podemos seguir añadiendo elementos al mismo del mismo modo que lo hacíamos con el uso de la función highchart(). La agrupación por colores es debida al modificador de grupo group=grpen la función hcaes(). Si no lo ponemos, simplemente el color sería único. hchart(dfextra, &#39;scatter&#39;, hcaes(x=mat, y=bio)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Una última variación al scatterplot sería convertirlo en un bubble scatterplot. Un diagrama de burbujas es un diagrama de dispersión donde se agrega una tercera dimensión: el valor de una variable numérica adicional se representa mediante el tamaño de los puntos. Necesita 3 variables numéricas como entrada: una está representada por el eje X, una por el eje Y y otra por el tamaño del punto. Más vale un imagen que mil palabras. hchart(dfextra, &#39;scatter&#39;, hcaes(x=mat, y=bio, z=glob, group = grp)) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) 9.10 Histograma o gráfico de densidad También en este caso vamos a recurrir a la forma simple. Un histograma solo toma como entrada una variable numérica. La variable se divide en varios cortes y el número de observaciones por corte se representa mediante la altura de la barra. Es posible representar la distribución de varias variables en el mismo eje utilizando esta técnica. Sigamos utilizando nuestro nuevo dataframe dfextra. hchart(dfextra$mat, color=&#39;teal&#39;, name=&#39;Matemáticas&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Este gráfico puede fácilmente reconvertirse a la función de densidad. Una gráfica de densidad muestra la distribución de una variable numérica. Solo toma variables numéricas como entrada y está muy cerca de un histograma. Puede usarse exactamente en las mismas condiciones. hchart(density(dfextra$mat), color=&#39;teal&#39;, name=&#39;Matemáticas&#39;) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) 9.11 Gráficos indicadores Estos gráfico están caracterizados en su mayor parte por presentar un único valor numérico en una imagen muy simplificada. Su mayor exponente es el denominado gauge que estamos acostumbrados a ver en multitud de páginas web de tipo dashboard. Se caracterizan por tener datos que se proporcionan de forma externa al dataframe de donde se representa la información. Veamos algunos ejemplos. 9.11.1 Gauge Un gráfico de indicador (o gráfico de velocímetro) combina un gráfico de anillo y un gráfico circular en un solo gráfico. Muestra el valor deseado al que se le presupone un valor mínimo y un máximo. Es muy típico para representar por ejmplo el NPS y presentarlo con secciones tipo semáforo. En nuestro script y con afán de ir probando nuevas cosas, crearemos primero lo que se denominan las secciones del semáforo (3 o n) y luego haremos el gráfico. Representemos el campo value de nuestras frutas, comenzando por la oliva (fila 3) . Presentamos el script de forma más extendida para ir apreciando y comentando alguno de sus detalles col_stops &lt;- data.frame( q = c(0.25, 0.50, 0.75), # se establecen las secciones de valor en término porcentual c = c(&#39;#CD5C5C&#39;, &#39;#F0E68C&#39;, &#39;#3CB371&#39;), # se establecen los colores que tomará cada sección stringsAsFactors = FALSE ) stops &lt;- list_parse2(col_stops) # se crea una lista con este dataframe que hemos creado, pues highcharts lo necesita así. highchart() %&gt;% hc_chart(type = &quot;solidgauge&quot;) %&gt;% hc_pane( startAngle = -90, # determina el ángulo donde comienza endAngle = 90, # determina el ángulo donde acaba background = list( outerRadius = &#39;100%&#39;, # &quot;vaciamos&quot; el hueco del círculo que hemos dibujado innerRadius = &#39;60%&#39;, # &quot;vaciamos&quot; el hueco del círculo que hemos dibujado shape = &quot;arc&quot; ) ) %&gt;% hc_tooltip(enabled = FALSE) %&gt;% hc_yAxis( stops = stops, # le aplicamos la lista de secciones colo (semáforo) lineWidth = 0, minorTickWidth = 0, tickAmount = 2, min = 0, max = 100, labels = list(y = 25) # baja las etiquetas 0 y 100 de límites para que no sitúen sobre el gráfico ) %&gt;% hc_add_series( data = df$high[3], # le indicamos que capturamos el valor desde dataframe &#39;df&#39;, del campo &#39;high&#39;, y la fila &#39;3&#39; dataLabels = list( borderWidth = 0, useHTML = TRUE, style = list(fontSize = &quot;60px&quot;) ) ) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Prueba si lo deseas a ir cambiando el valor de df$high[3] a cualquier valor entre 0 y 10 y observarás el cambio de color. col_stops &lt;-data.frame(q = c(0.25, 0.50, 0.75),c = c(&#39;#CD5C5C&#39;, &#39;#F0E68C&#39;, &#39;#3CB371&#39;),stringsAsFactors = FALSE) stops &lt;- list_parse2(col_stops) highchart() %&gt;% hc_chart(type = &quot;solidgauge&quot;) %&gt;% hc_pane(startAngle = -90,endAngle = 90,background = list(outerRadius = &#39;100%&#39;,innerRadius = &#39;60%&#39;,shape = &quot;arc&quot; )) %&gt;% hc_tooltip(enabled = FALSE) %&gt;% hc_yAxis(stops = stops,lineWidth = 0,minorTickWidth = 0,tickAmount = 2,min = 0,max = 100,labels = list(y = 25)) %&gt;% hc_add_series(data = 65,dataLabels = list(borderWidth = 0,useHTML = TRUE,style = list(fontSize = &quot;60px&quot;))) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) 9.11.2 Bullet Otra forma de representar valores unitario pero que tienen un objetivo definido y que pueden haber superado ese objetivo es el gráfico denominado bullet. vamos a imaginar que en nuestro dataframe, y es el valor alcanzado, y valuees el objetivo. bandas &lt;- list(list(from = 0, to = 10, color = &quot;#ddd&quot;),list(from = 10, to = 20, color = &quot;#bbb&quot;),list(from = 20, to = 25, color =&quot;#888&quot;)) hchart(df1, &quot;bullet&quot;, hcaes(x = name, y = y, target = value), color = &quot;teal&quot;, targetOptions=list(color=&#39;black&#39;)) %&gt;% hc_chart(inverted = TRUE) %&gt;% hc_yAxis(min = 0,max = 25, gridLineWidth = 0, plotBands = bandas) %&gt;% hc_xAxis(gridLineWidth = 15, gridLineColor = &quot;white&quot;) %&gt;% hc_plotOptions(series = list(pointPadding = 0.25, pointWidth = 15, borderWidth = 0, targetOptions = list(width = &#39;200%&#39;))) %&gt;% hc_size(height = 300)%&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Nótese que en el gráfico la barra vertical perpendicular a cada barra horizontal, que es el target se toma de los propios datos. Es un gráfico que también se ve mucho en los dashboard, al igual que el anterior. 9.12 Gráfico / boxplot No lo hemos olvidado, el gráfico más típico en estadística junto con los histogramas, el denominado boxplot o diagrama de caja o diagrama de Box-Whiskers. Un diagrama de caja ofrece un buen resumen de una o varias variables numéricas. La línea que divide el cuadro en 2 partes representa la mediana de los datos. El final del cuadro muestra los cuartiles superior e inferior. Las líneas extremas muestran el valor más alto y más bajo excluyendo los valores atípicos. Nótese que es usada una función de tranformación de los datos del campo valuepara obtener los valores adecuados para el gráfico. Del mismo modo, nótese que la función de adición de las series, se ve mínimamente modificada ya que va a recibir una lista de valores por cada campos de trabajo. Usamos hc_add_series_list(). dfboxplot1 &lt;- data_to_boxplot(df, value, add_outliers=TRUE, name= &#39;value&#39;, color = &#39;teal&#39;) highchart() %&gt;% hc_chart(type=&#39;boxplot&#39;) %&gt;% hc_add_series_list(dfboxplot1) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) Añadir más series sólo implica repetir el proceso, lo que permite la compración. dfboxplot1 &lt;- data_to_boxplot(df, value, add_outliers=TRUE, name= &#39;value&#39;, color = &#39;teal&#39;) dfboxplot2 &lt;- data_to_boxplot(df, high, add_outliers=TRUE, name= &#39;high&#39;, color = &#39;red&#39;) dfboxplot3 &lt;- data_to_boxplot(df, low, add_outliers=TRUE, name= &#39;low&#39;, color = &#39;orange&#39;) highchart() %&gt;% hc_chart(type=&#39;boxplot&#39;) %&gt;% hc_add_series_list(dfboxplot1) %&gt;% hc_add_series_list(dfboxplot2) %&gt;% hc_add_series_list(dfboxplot3) %&gt;% hc_credits(enabled=TRUE, text=&#39;InvestigaOnline.com&#39;, href =&#39;https://www.investigaonline.com&#39;) %&gt;% hc_exporting(enabled=TRUE) 9.13 Gráfico de barras de error A menudo tenemos necesidad de incluir un gráfico denominado de barras de error. Este gráfico toma los valores de low-high (que podrían ser lo límites de confianza de un intervalo) y los representa en forma gráfica, quedando de esta forma. highchart() %&gt;% hc_chart(type = &#39;errorbar&#39;, polar = FALSE, inverted = FALSE) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_yAxis(visible = TRUE) %&gt;% hc_tooltip(outside = TRUE, enabled=TRUE) %&gt;% hc_add_series(df,name = &quot;Límites de confianza&quot;,showInLegend = FALSE, dataLabels = list(enabled=TRUE)) Si además de los límites de la medición, quisiéramos añadir el punto de valor, el resultado sería éste. highchart() %&gt;% hc_chart(type = &#39;errorbar&#39;, polar = FALSE, inverted = FALSE) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_yAxis(visible = TRUE) %&gt;% hc_tooltip(outside = TRUE, enabled=TRUE) %&gt;% hc_add_series(df,name = &quot;Límites de confianza&quot;,showInLegend = FALSE, dataLabels = list(enabled=TRUE)) %&gt;% hc_add_series(df,type = &#39;scatter&#39;, name = &quot;Valor&quot;,showInLegend = FALSE, dataLabels = list(enabled=TRUE, x=15, y=5)) Probando nuevas cosas, hemos movido la etiqueta del valor hacia la derecha (x=15) y hacia abajo (y=5). Eso hace que no se solape con el punto señalado en el gráfico. 9.14 Gráficos de transiciones En nuestro trabajo en mucho casos debemos a veces plantear gráficos en los que se trata de graficar relaciones de objetos con fuente y destino. Aunque nuestro banco de datos es muy simple, hemos creado campos con el nombrede weight, from y to para que nos permitan hacer este tipo de gráficos que tienen dos versiones diferentes: el diagrama de Sankey y el diagrama de rueda de dependencia. Veamos ambos. 9.14.1 Diagrama de Sankey El diagrama de Sankey es un tipo específico de diagrama de flujo, en el que la anchura de las linea de relación entre dos puntos (from y to) se muestra proporcional a la cantidad de flujo transferido (weight, que podría ser frecuencia de emparejamiento). highchart() %&gt;% hc_chart(type = &#39;sankey&#39;, polar = FALSE, inverted = FALSE) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_yAxis(visible = TRUE) %&gt;% hc_tooltip(outside = TRUE, enabled=TRUE) %&gt;% hc_add_series(df,name = &quot;Nombre de la serie&quot;,showInLegend = FALSE, dataLabels = list(enabled=TRUE), colorByPoint=TRUE) De esta forma se muestra que las relaciones más fuertes se producen entre aceituna y pera o entre guava y pera. 9.14.2 Diagrama de rueda Otra forma de ver el mismo gráfico, pero en forma circular. Las mismas necesidades de campos weight, from y to. highchart() %&gt;% hc_chart(type = &#39;dependencywheel&#39;, polar = FALSE, inverted = FALSE) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_yAxis(visible = TRUE) %&gt;% hc_tooltip(outside = TRUE, enabled=TRUE) %&gt;% hc_add_series(df,name = &quot;Nombre de la serie&quot;,showInLegend = FALSE, dataLabels = list(enabled=TRUE), colorByPoint=TRUE) 9.14.3 Diagrama streamgraph Un streamgraph es un tipo de gráfico de áreas apiladas. Muestra la evolución de un valor numérico (eje Y) después de otro valor numérico (eje X). Esta evolución está representada por varios grupos, todos con un color distinto. Al contrario que en un área apilada, no hay esquinas: los bordes están redondeados, lo que da esta agradable impresión de flujo. Además, las áreas generalmente se desplazan alrededor de un eje central, lo que da como resultado una forma fluida y orgánica. Usaremos los valores y, z y value para crear tres series. highchart() %&gt;% hc_chart(type = &#39;streamgraph&#39;, polar = FALSE, inverted = FALSE) %&gt;% hc_xAxis(categories = df$name) %&gt;% hc_yAxis(visible = TRUE) %&gt;% hc_tooltip(outside = TRUE, enabled=TRUE) %&gt;% hc_add_series(df$y,name = &quot;y&quot;, showInLegend = FALSE, dataLabels = list(enabled=FALSE), color=&#39;silver&#39;) %&gt;% hc_add_series(df$z,name = &quot;z&quot;, showInLegend = FALSE, dataLabels = list(enabled=FALSE), color=&#39;teal&#39;) %&gt;% hc_add_series(df$value ,name = &quot;value&quot;, showInLegend = FALSE, dataLabels = list(enabled=FALSE), color=&#39;orange&#39;) 9.14.4 Diagrama de redes Para finalizar como homenaje a mis compañeros en TESI, quiero poner este gráfico muy de moda en la actualidad para representar transiciones, flujos o relaciones más complejas. Como es obvio, recogemos los datos de forma externa (ocultamos el código de carga) y presentamos los mismos en la imagen. El gráfico muestra nuestra relaciones de proyecto y de unidades de negocio de modo interno. #edges contiene las relaciones mientras que names contiene los elementos g &lt;- graph_from_data_frame(edges, directed=TRUE, vertices=names) hchart(g, layout = layout_with_fr, dataLabels=list(enabled = TRUE, format=&#39;{point.name}&#39;)) %&gt;% hc_title(text=&#39;TESI&#39;, useHTML=TRUE) %&gt;% hc_tooltip(useHTML = TRUE, pointFormat = &quot;{point.photo}&quot;) 9.15 Conclusión Hasta aquí llegamos. Hemos presentado de forma muy breve y simplificada como podemos aprovechar toda la potencia de highcharts en nuestros scripts. Lo importante es practicar y practicar. No dejes de leer el post de Danton Noriega acerca de como usar la API para saber construir los gráficos highchart en R mediante highcharteR Del mismo modo, no dejes de acudir al sitio web de Joshua Kunst, creador y mantenedor del paquete junto con otros colaboradores que permiten llevar adelante este excelente proyecto. Bibliografía "],["tse-formateo.html", "Capítulo 10 Estilos y formatos de tabla 10.1 Introducción 10.2 Operaciones con tablas 10.3 Estilo de las tablas 10.4 Adición de imágenes y de otros elementos", " Capítulo 10 Estilos y formatos de tabla .. en desarrollo 10.1 Introducción Los paquetes que hemos utilizado en nuestro trabajo con las tablas ya han sido referido en multitud de ocasiones. expss nos permite además de obtener el cuadro preciso, operar con las filas y columnas de la tabla, puesto que el objeto creado es como un dataframe especial, ya que su clase de objeto es etable. Por tanto, vamos a tener la capacidad de poder operar con las columnas (variable) así como también con las filas (registros de ese dataframe). Existen multitud de paquetes con los que poder interactuar para poder obtener los resultados deseados. Los paquetes DT (datatable), formattable, y también kable y kableExtra que son nativos para utilizar junto con rmarkdown, lo que conforma un amplio espectro de soluciones. Deberemos buscar aquella que responda a nuestras expectativas y que haga nos sintamos más cómodos. Por el lado de las operaciones en la tabla, comenzaremos sentando las bases de como se realizan las operaciones, para luego trabajar la salida aportando estilos y formatos condicionales a las mismas. 10.2 Operaciones con tablas Como hemos indicado en la presentación anterior, nuestro primer paso será la realización de operaciones muy simples con las tablas, que seguro en nuestro trabajo estamos acostumbrados a hacer. también vamos a adentramos un poco en la creación de los elementos con los que vamos a trabajar. Ahora ya no trabajaremos sobre lo que ha sido nuestro fichero base, sino que iremos aportando nuestros propios ejemplos que se adecuen a lo que deseamos hacer. Imaginemos que disponemos datos sobre las cifras de ventas anuales de cinco empresas muy conocidas: Apple, Amazon, Microsoft, Google y Facebook. Estas empresas ofrecen información sobre Ingresos , Beneficio Operativo y Beneficio Neto de cuatro trimestre de 2018 y primer trimestre de 2019 en millones de dólares. Con estos datos creamos un dataframe. data &lt;- data.frame(emp=c(&#39;Apple&#39;,&#39;Apple&#39;, &#39;Microsoft&#39;,&#39;Microsoft&#39;, &#39;Amazon&#39;,&#39;Amazon&#39;, &#39;Google&#39;,&#39;Google&#39;, &#39;Facebook&#39;,&#39;Facebook&#39;), ing=c(84310,91819,32471,36906,72400,87400, 39276,46075,16914,21082), bfo=c(23346,25569,10258,13891,3786,3879,8221,9266,7820,8858), bfn=c(19965,22236,8420,11649,3027,3268,8948,10671,6882,7349), per=c(&#39;IV-2018&#39;,&#39;I-2019&#39;,&#39;IV-2018&#39;,&#39;I-2019&#39;,&#39;IV-2018&#39;,&#39;I-2019&#39;,&#39;IV-2018&#39;,&#39;I-2019&#39;,&#39;IV-2018&#39;,&#39;I-2019&#39;) ) data ## emp ing bfo bfn per ## 1 Apple 84310 23346 19965 IV-2018 ## 2 Apple 91819 25569 22236 I-2019 ## 3 Microsoft 32471 10258 8420 IV-2018 ## 4 Microsoft 36906 13891 11649 I-2019 ## 5 Amazon 72400 3786 3027 IV-2018 ## 6 Amazon 87400 3879 3268 I-2019 ## 7 Google 39276 8221 8948 IV-2018 ## 8 Google 46075 9266 10671 I-2019 ## 9 Facebook 16914 7820 6882 IV-2018 ## 10 Facebook 21082 8858 7349 I-2019 Ahora vamos a obtener la tabla con la que deseamos trabajar, que sería comparar los ingresos de las cinco compañías en los dos períodos. Para ello creamos una tabla de la siguiente forma. data %&gt;% tab_cols(per) %&gt;% tab_rows(emp) %&gt;% tab_cells(ing) %&gt;% tab_stat_sum() %&gt;% tab_pivot() per I-2019 IV-2018 emp Amazon ing Sum 87400 72400 Apple ing Sum 91819 84310 Facebook ing Sum 21082 16914 Google ing Sum 46075 39276 Microsoft ing Sum 36906 32471 Este sería el formato estándar de salida, pero como ya hemos visto e capítulos anteriores, podemos adaptar esa salida a nuestras necesidades. Nótese que aun no siendo necesario, vamos a guardar la tabla en un output llamado tab01 que luego vamos a publicar. Utilizamos la función class()para mostrarte que tras hacer la tabla, el output almacenado es un etable dataframe. tab01 &lt;- data %&gt;% tab_cols(&#39;|&#39;=unvr(per)) %&gt;% tab_rows(&#39;|&#39;=unvr(emp)) %&gt;% tab_cells(&#39;|&#39;=unvr(ing)) %&gt;% tab_stat_sum(label=&#39;|&#39;) %&gt;% tab_pivot() class(tab01) ## [1] &quot;etable&quot; &quot;data.frame&quot; tab01 I-2019 IV-2018 Amazon 87400 72400 Apple 91819 84310 Facebook 21082 16914 Google 46075 39276 Microsoft 36906 32471 Podemos ver que esta tabla ya tiene un formato más adecuado a nuestra necesidad. Hemos quitado aquellos textos que en esta ocasión eran innecesarios. Si convertimos (aunque ya lo es) y mostramos esta tabla como dataframe el resultado sería éste. tab01 &lt;- as.data.frame(tab01) class(tab01) ## [1] &quot;data.frame&quot; tab01 ## row_labels I-2019 IV-2018 ## 1 Amazon 87400 72400 ## 2 Apple 91819 84310 ## 3 Facebook 21082 16914 ## 4 Google 46075 39276 ## 5 Microsoft 36906 32471 Nótese que ahora ya el output no es un objeto de tipo etable, solo es dataframe. Ya estamos en condiciones de poder operar. Calculemos la diferencia entre los dos trimestres. tab01$dif &lt;- tab01[,2]-tab01[,3] tab01 ## row_labels I-2019 IV-2018 dif ## 1 Amazon 87400 72400 15000 ## 2 Apple 91819 84310 7509 ## 3 Facebook 21082 16914 4168 ## 4 Google 46075 39276 6799 ## 5 Microsoft 36906 32471 4435 Esta información puede ser presentada en un gráfico tal como veíamos en el capítulo anterior. Aprovechemos también para cambiar el nombre de las columnas  colnames(tab01) &lt;- c(&#39;empresa&#39;, &#39;2019 (1º)&#39;, &#39;2018 (4º)&#39;, &#39;dif&#39;) highchart() %&gt;% hc_chart(type=&#39;column&#39;) %&gt;% hc_title(text=&#39;Cifra de negocio de las 5 mayores tecnológicas&#39;) %&gt;% hc_xAxis(categories=tab01[,1]) %&gt;% hc_yAxis(min=0, max=100000) %&gt;% hc_add_series(data=tab01[,2], name=&#39;IV de 2018&#39;,dataLabels=list(enabled=TRUE), color=&#39;salmon&#39;) %&gt;% hc_add_series(data=tab01[,3], name=&#39;I de 2019&#39;,dataLabels=list(enabled=TRUE), color=&#39;darksalmon&#39;) %&gt;% hc_add_series(data=tab01[,4], name=&#39;Diferencia&#39;,dataLabels=list(enabled=TRUE), color=&#39;teal&#39;) Figure 10.1: Gráfico del dataframe Añadamos más información a la tabla. Vamos a calcular el porcentaje de incremento. Habrían muchas formas de hacerlo, pero vamos a tratar de hacerlo de la forma más simple. tab01$difpct &lt;- round(((tab01[,2]/tab01[,3])-1)*100,1) #cociente entre valores y paso a porcentaje con redondeo a un decimal tab01 ## empresa 2019 (1º) 2018 (4º) dif difpct ## 1 Amazon 87400 72400 15000 20.7 ## 2 Apple 91819 84310 7509 8.9 ## 3 Facebook 21082 16914 4168 24.6 ## 4 Google 46075 39276 6799 17.3 ## 5 Microsoft 36906 32471 4435 13.7 Esto nos va a permitir probar algo que no vimos en el anterior capítulo, presentar en función de otro eje Y la información. Se puede observar que en el script abajo referido, estamos creando en la función hc_yAxis() una lista de dos ejes a los que referenciar los datos, mientras que las cifras absolutas se miran con el eje Y de la izquierda, el dato relativo se mira con el eje Y a la derecha del gráfico. El resto de opciones ya fueron analizadas highchart() %&gt;% hc_chart(type=&#39;column&#39;) %&gt;% hc_title(text=&#39;Cifra de negocio de las 5 mayores tecnológicas&#39;) %&gt;% hc_xAxis(categories=tab01[,1]) %&gt;% hc_yAxis_multiples(list(title = list(text = &#39;Millones de dólares&#39;), min=0, max=100000),list(title = list(text = &#39;Porcentaje&#39;), min=0,max=100, opposite = TRUE))%&gt;% hc_add_series(data=tab01[,2], name=&#39;IV de 2018&#39;,dataLabels=list(enabled=TRUE), color=&#39;salmon&#39;) %&gt;% hc_add_series(data=tab01[,3], name=&#39;I de 2019&#39;,dataLabels=list(enabled=TRUE), color=&#39;darksalmon&#39;) %&gt;% hc_add_series(data=tab01[,4], name=&#39;Diferencia&#39;,dataLabels=list(enabled=TRUE), color=&#39;teal&#39;) %&gt;% hc_add_series(data=tab01[,5], name=&#39;Diferencia porcentual&#39;,dataLabels=list(enabled=TRUE, format=&#39;{point.y} %&#39;), color=&#39;darkblue&#39;, yAxis=1) Figure 10.2: gráfic del dataframe 10.3 Estilo de las tablas 10.3.1 Estilo y posición Vamos ahora a trabajar con la con la tabla y realizaremos algunos cambios sobre ella. Utilizaremos el paquete kableExtra. Este paquete permite trabajar con los dataframe para formatear la manera en que se van a mostrar en la pantalla. Existen multitud de paquetes que nos permitirían hacer cosas semejantes, entre los que podríamos destacar formattable, DT o flextable entre otros. Nuestro primer cambio va a ser mostrar de forma diferente nuestra tabla. Con un estilo diferente a lo que ha aprecido hasta ahora. Le vamos a aplicar el estilo típico de Bootstrap, conocida librería JS con la que fue desarrollada Twitter. Te recomendamos visitar la viñeta del paquete en este sitio si quieres ver todas sus posibilidades. kbl(tab01) %&gt;% kable_styling() empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Se puede apreciar que el aspecto es diferente al mostrado por las tablas hasta ahora. Este sería el formato más básico de Bootstrap. Existen otras opciones entre las que vamos a ir añadiendo algunas características, aplicables a los formatos. Usando paper kbl(tab01) %&gt;% kable_paper(&#39;hover&#39;) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Usando classic kbl(tab01) %&gt;% kable_classic(&#39;hover&#39;) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Usando minimal kbl(tab01) %&gt;% kable_minimal(&#39;hover&#39;) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Añadimos además del efecto hover con el ratón, el oscurecimiento o striped de las filas para facilitar la lectura y usabilidad. kbl(tab01) %&gt;% kable_material(c(&#39;striped&#39;,&#39;hover&#39;)) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Finalizamos de nuevo con el primer formato que será el que mantendremos a partir de este momento. kbl(tab01) %&gt;% kable_styling(bootstrap_options = c(&#39;striped&#39;, &#39;hover&#39;, &#39;condensed&#39;, &#39;responsive&#39;)) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Una de las características que en algunos casos puede ser muy valiosa, es la posibilidad de establecer la tabla como flotante a derecha o izquierda del texto. kbl(tab01) %&gt;% kable_styling(bootstrap_options = c(&#39;striped&#39;, &#39;hover&#39;, &#39;condensed&#39;, &#39;responsive&#39;), full_width = F, position = &#39;float_right&#39;) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Este texto que estamos escribiendo, se ubicaría a la izquierda de la tabla, ya que hemos indicado que ésta debe ser situada a la derecha como elemento flotante. Al mismo tiempo se le ha incluido la posibilidad de que la tabla no ocupe el 100% del espacio sino que se autoajuste al tamaño de las columna. Este efecto puede ser muy utilizado para incluir comentarios sobre la tabla que estamos publicando. Como es lógico, la tabla puede ser flotante a la derecha o a la izquierda del texto. Existen otras muchas características que pueden ser aplicadas para conseguir posicionar la tabla de la forma deseada: fijar la cabecera incluir la tabla en una caja aplicar tamaños de fuente  y más. 10.3.2 Formato específico de fila o columna Veamos algunas de las posibilidades que nos ofrece kableExtrapara formatear partes de la tabla. Para ello debemos saber que las columnas se identifican por número secuencial (1 a n) al igual que las filas. Se pueden aplicar formatos tanto a filas como a columnas. Para ilustrar un ejemplo, vamos a utilizar una función de R muy frecuente denominada ifelse() que es el equivalente a la función SI() de Excel y con una estructura idéntica. Esta función admite la concatenación y sus parámetros son por este orden: condición que debe cumplirse resultado si verdadero resultado si falso En nuestro caso nuestro resultado es la aplicación de un color verde o rojo según estemos por encima o por debajo de la media de la columna. Del mismo modo, también se puede aplicar como podemos observar un color directo a una columna determinada. Usaremos la función column_spec(). kbl(tab01) %&gt;% kable_styling(bootstrap_options = c(&#39;striped&#39;, &#39;hover&#39;, &#39;condensed&#39;, &#39;responsive&#39;), full_width = F) %&gt;% column_spec(2, color = &#39;teal&#39;, bold = TRUE) %&gt;% column_spec(5, color = &#39;white&#39;, background = ifelse(tab01$difpct&gt;mean(tab01$difpct), &#39;green&#39;, &#39;salmon&#39;),popover = paste(tab01[,1])) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Otra posibilidad es la de poder marcar celdas cell_spec() o filas con row_spec()en particular  kbl(tab01) %&gt;% kable_styling(bootstrap_options = c(&#39;striped&#39;, &#39;hover&#39;, &#39;condensed&#39;, &#39;responsive&#39;), full_width = F) %&gt;% row_spec(3:5, bold = T, color = &#39;white&#39;, background = &#39;teal&#39;) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Un caso particular para la fila 0, la de encabezado. kbl(tab01) %&gt;% kable_styling(c(&#39;striped&#39;,&#39;hovered&#39;), full_width = F) %&gt;% row_spec(0, angle = -20, align = &#39;left&#39;, background = &#39;teal&#39;, color = &#39;white&#39;, bold = TRUE) %&gt;% row_spec(1:5, align = &#39;center&#39;, background = &#39;lightsalmon&#39;) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 10.4 Adición de imágenes y de otros elementos Ya para finalizar, es muy habitual querer utilizar imágenes para ilustrar la tabla, darle un aspecto más impactante. Vemos como hacerlo. Esta imagen puede sustituir el contenido completo de la columna o añadirse al final de la misma. En nuestro ejemplo queremos sustituir, por lo que nuestra primera instrucción limpia la columna de tab01 denominada empresa. Posteriormente se crea un vector con las cinco imágenes que aprovecharemos en la columna 1. Para no perder nuestra tabla original, hacemos un copia de la misma en tab02. tab02 &lt;- tab01 tab02$empresa &lt;- &#39;&#39; vector.img &lt;- c(&#39;https://download.tesigandia.com/test/20201112113121.png&#39;, &#39;https://download.tesigandia.com/test/20201112112927.png&#39;, &#39;https://download.tesigandia.com/test/20201112113240.png&#39;, &#39;https://download.tesigandia.com/test/20201112113259.png&#39;, &#39;https://download.tesigandia.com/test/20201112113048.png&#39;) kbl(tab02) %&gt;% kable_styling(bootstrap_options = c(&#39;hover&#39;), full_width = FALSE) %&gt;% column_spec(1, image = vector.img) %&gt;% column_spec(2, color = &#39;teal&#39;, bold = TRUE) %&gt;% column_spec(5, color = &#39;white&#39;, background = ifelse(tab02$difpct&gt;mean(tab02$difpct), &#39;green&#39;, &#39;salmon&#39;)) empresa 2019 (1º) 2018 (4º) dif difpct 87400 72400 15000 20.7 91819 84310 7509 8.9 21082 16914 4168 24.6 46075 39276 6799 17.3 36906 32471 4435 13.7 10.4.1 Adición de iconos de FontAwesome En la siguiente tabla, vamos a añadir las marcas de icono llamadas fontawesome que permite reproducir en modo texto los iconos más típicos. En nuestro caso y siguiendo el uso de la función ifelse que hemos visto antes, añadiremos una flecha arriba verde si la media de la cifra de negocio es mayor que la media o una flecha abajo roja si es menor. tab02 &lt;- tab01 tab02[,2] &lt;- ifelse(tab02[,2]&gt;mean(tab02[,2]), paste(tab02[,2], fa(&#39;arrow-circle-up&#39;, fill=&#39;green&#39;)), paste(tab02[,2], fa(&#39;arrow-circle-down&#39;, fill=&#39;red&#39;))) kbl(tab02, escape=FALSE) %&gt;% kable_styling(bootstrap_options = c(&#39;striped&#39;, &#39;hover&#39;, &#39;condensed&#39;, &#39;responsive&#39;), full_width = F) %&gt;% column_spec(2, color = &#39;teal&#39;, bold = TRUE) %&gt;% column_spec(5, color = &#39;white&#39;, background = ifelse(tab02$difpct&gt;mean(tab01$difpct), &#39;green&#39;, &#39;salmon&#39;),popover = paste(tab02[,1])) empresa 2019 (1º) 2018 (4º) dif difpct Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 10.4.2 Adición de gráficos de tipo sparkline Dado que no tenemos datos para poder representar, vamos a suponer una serie de datos para cada empresa y vamos a hacer un gráfico de líneas de tipo sparkline, que vamos a integra como una columna más de nuestra tabla. sparkline es un paquete de R que utiliza la librería jquery sparklines para presentar gráficos minimalistas y ser integrados en nuestros dataframe, y por tanto, publicados en tablas. En primer lugar creamos la serie de datos para cada empresa y lo vamos a hacer usando la función sample() que nos aportará 15 valores aleatorios entre 1 y 100 con posibilidad de repetición. Esta es una fórmula muy sencilla que se utiliza mucho en R para crear datos de test. sparkline(0) #inicializamos la función sparkline amz &lt;- sample(1:100, 15, replace = TRUE) app &lt;- sample(1:100, 15, replace = TRUE) fac &lt;- sample(1:100, 15, replace = TRUE) goo &lt;- sample(1:100, 15, replace = TRUE) mic &lt;- sample(1:100, 15, replace = TRUE) df &lt;- data.frame(amz,app,fac,goo,mic) # los unimos para mostrarlos en forma de tabla, aunque no sería necesario. df amz app fac goo mic 1 64 85 71 43 20 2 70 85 80 28 55 3 86 17 7 30 21 4 76 42 42 85 72 5 54 35 91 57 9 6 65 29 4 23 25 7 71 75 26 46 72 8 82 88 75 93 100 9 4 13 66 3 84 10 82 18 44 47 18 11 79 75 21 54 30 12 17 4 73 27 6 13 56 27 9 96 72 14 49 27 65 4 99 15 91 59 36 17 95 Una vez tenemos esto Lo hemos juntado en un _dataframe para que se vea mejor, vamos a añadir una nueva columna a nuestra tabla, con la información del gráfico. tab03 &lt;- tab01 tab03$sparkline = c(spk_chr(amz), spk_chr(app), spk_chr(fac), spk_chr(goo), spk_chr(mic)) kbl(tab03, escape = F) %&gt;% kable_styling(full_width=TRUE) empresa 2019 (1º) 2018 (4º) dif difpct sparkline Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 La última columna de la tabla muestra los gráficos obtenidos. Nótese que los datos de la última columna han sido calculados con una fuente de datos diferente, por lo que esta tabla está presentando inputs obtenidos de dos fuentes. Por una lado nuestra vieja tabla y por otro lado la nueva información que le incorporamos. Y finalmente, mostramos casi todo lo que hemos hecho junto, no son cosas separadas. tab02 &lt;- tab03 tab02[,2] &lt;- ifelse(tab02[,2]&gt;mean(tab02[,2]), paste(tab02[,2], fa(&#39;arrow-circle-up&#39;, fill=&#39;green&#39;)), paste(tab02[,2], fa(&#39;arrow-circle-down&#39;, fill=&#39;red&#39;))) kbl(tab02, escape=FALSE) %&gt;% kable_styling(bootstrap_options = c(&#39;striped&#39;, &#39;hover&#39;, &#39;condensed&#39;, &#39;responsive&#39;), full_width = F) %&gt;% column_spec(2, color = &#39;teal&#39;, bold = TRUE) %&gt;% column_spec(5, color = &#39;white&#39;, background = ifelse(tab02$difpct&gt;mean(tab01$difpct), &#39;green&#39;, &#39;salmon&#39;)) empresa 2019 (1º) 2018 (4º) dif difpct sparkline Amazon 87400 72400 15000 20.7 Apple 91819 84310 7509 8.9 Facebook 21082 16914 4168 24.6 Google 46075 39276 6799 17.3 Microsoft 36906 32471 4435 13.7 Si deseas consultar más información sobre la librería jQuery Sparklines accede al enlace. Enlace antiguo, pero con muchísima utilidad. "],["tse09.html", "Capítulo 11 Condiciones 11.1 Operadores aritméticos 11.2 Operadores relacionales 11.3 Operadores lógicos 11.4 Operadores de asignación 11.5 Operadores específicos (criterios) en expss", " Capítulo 11 Condiciones Los operadores son los símbolos que le indican a R que debe realizar una tarea. Combinando datos y operadores es que logramos que R haga su trabajo. Existen operadores específicos para cada tipo de tarea. Los tipos de operadores principales son los siguientes: Aritméticos Relacionales Lógicos De asignación Familiarizarnos con los operadores nos permitirá manipular y transformar datos de distintos tipos. 11.1 Operadores aritméticos Como su nombre lo indica, este tipo de operador es usado para operaciones aritméticas. En R tenemos los siguientes operadores aritméticos: Operador Operación Ejemplo Resultado + Suma 5 + 3 8 - Resta 5 - 3 2 * Multiplicación 5 * 3 18 / División 5 /3 1.666667 ^ Potencia 5 ^ 3 125 %% División entera 5 %% 3 2 11.2 Operadores relacionales Operador Comparación Ejemplo Resultado &lt; Menor que 5 &lt; 3 FALSE &lt;= Menor o igual que 5 &lt;= 3 FALSE &gt; Mayor que 5 &gt; 3 TRUE &gt;= Mayor o igual que 5 &gt;= 3 TRUE == Exactamente igual que 5 == 3 FALSE != No es igual que 5 != 3 TRUE 11.3 Operadores lógicos Los operadores lógicos son usados para operaciones de álgebra Booleana, es decir, para describir relaciones lógicas, expresadas como verdadero (TRUE) o falso (FALSO). Operador Comparación Ejemplo Resultado x y x Ó y es verdadero TRUE x &amp; y x Y y son verdaderos TRUE &amp; FALSE FALSE !x x no es verdadero (negación) !TRUE FALSE isTRUE(x) x es verdadero (afirmación) isTRUE(TRUE) TRUE Los operadores | y &amp; siguen estas reglas: devuelve TRUE si alguno de los datos es TRUE &amp; solo devuelve TRUE si ambos datos es TRUE solo devuelve FALSE si ambos datos son FALSE &amp; devuelve FALSE si alguno de los datos es FALSE Estos operadores pueden ser usados con estos con datos de tipo numérico, lógico y complejo. Al igual que con los operadores relacionales, los operadores lógicos siempre devuelven TRUE o FALSE. 11.4 Operadores de asignación Operador Operación &lt;- Asigna un valor a una variable = Asigna un valor a una variable Aunque podemos usar el signo igual para una asignación, a lo largo de este libro utilizaremos &lt;-, por ser característico de R y fácil de reconocer visualmente. Después de realizar la operación de asignación, podemos usar el nombre de la variable para realizar operaciones con ella, como si fuera del tipo de datos que le hemos asignado. Si asignamos un valor a una variable a la que ya habíamos asignado datos, nuestra variable conserva el valor más reciente. Además, esta operación nos permite guardar el resultado de operaciones, de modo que podemos recuperarlos sin necesidad de realizar las operaciones otra vez. 11.5 Operadores específicos (criterios) en expss [en desarrollo] "],["bibliografía.html", "Bibliografía", " Bibliografía "]]
