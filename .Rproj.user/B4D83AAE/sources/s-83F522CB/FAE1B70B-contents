# Pruebas inferenciales {#tse07}

Cuando trabajamos con tablas de contingencia es muy frecuente que sintamos la necesidad de tener que inferir acerca de la dependencia de las categorías analizadas o de las diferencias entre los grupos analizados. Siempre que nuestras variables cumplan con los requisitos que para ellas cada prueba establece (normalidad, homoscedasticidad, linealidad y en algunos casos independencia), podremos aplicar las pruebas inferenciales típicas con tablas de contingencia en la investigación básica:

* Chi<sup>2</sup> en su variantes de tabla y celda;
* Pruebas z de contraste proporciones;
* Prueba t de contraste de medias.

Para todas ellas`expss` nos da la oportunidad de hacer los cálculos desde el propio script de realización de la tabla y/o desde una instrucción posterior a la realización de la tabla. Pasemos por ello a explicar, no tanto el cometido de estas pruebas, sino el como llevarlas adelante.

## Prueba de dependencia

El contraste Chi<sup>2</sup> de Pearson es una prueba estadística no paramétrica, que compara las frecuencias realmente obtenidas con las frecuencias esperadas que son las que corresponderían a cada celda o casilla de la tabla si su valor se ajustase a cualquier norma teórica previamente adoptada; en nuestro caso, una distribución proporcional de frecuencias normales. En definitiva, “se está calculando un índice acerca de la distancia entre lo real y lo esperado” @manzano1995.

El valor numérico de esta prueba se obtiene como:

<div style="text-align: center">![](data/embim12.png)</div>

* f<sub>o</sub>, serán las frecuencias observadas en el experimento o muestra
* f<sub>e</sub>, serán las frecuencias esperadas teóricamente

Las frecuencias esperadas se calculan con ...

<div style="text-align: center">![](data/embim13.png)</div>

* f<sub>o</sub>, serán las frecuencias observadas en el experimento o muestra
* f<sub>e</sub>, serán las frecuencias esperadas teóricamente
* N, es el número de efectivos muestrales

Esta prueba se suele utilizar (entre muchas otras posibilidades) para contrastar la hipótesis nula que los resultados obtenidos de una muestra no son significativos con relación a la población total, o bien como prueba de dependencia para comprobar la existencia o no de asociación entre las variables. En este caso, la prueba indica la existencia de asociación pero no la cuantifica @manzano1995.

### De una tabla

La prueba Chi<sup>2</sup> puede hacerse a nivel de tabla, lo que muestra la relación de dependencia entre las categorías. Hagamos una primera aproximación con dos tablas de contingencia muy sencillas, pero que nos mostrarán como se indica que la relación de dependencia existe o no existe. La función [`tab_last_sig_cases`](https://www.rdocumentation.org/packages/expss/versions/0.10.5/topics/tab_significance_options) realiza la prueba base de R denominada [`chisq.test`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/chisq.test).

Nótese el uso de '|'=unvr() para utilizar la variable sin que se publiquen los texto extra de la misma.

```{r fig.cap='Prueba Chi<sup>2</sup> en tabla', out.width='80%', fig.asp=.75, fig.align='center', echo=TRUE, warning=FALSE}
as.datatable_widget(data %>% 
    tab_cols(total(), '|'=unvr(P31)) %>% 
    tab_cells('|'=unvr(P2)) %>% 
    tab_stat_cases() %>% 
    tab_last_sig_cases() %>%
    tab_pivot())

as.datatable_widget(data %>% 
    tab_cols(total(), '|'=unvr(P31)) %>% 
    tab_cells('|'=unvr(P33)) %>% 
    tab_stat_cases() %>% 
    tab_last_sig_cases() %>%
    tab_pivot())
```

En la primera tabla se muestra la relación entre la variable  P31 (sexo) y la P2 (valoración del sistema sanitario). Nótese que en la tabla se ha usado una línea tras el cálculo de los casos con la función `tab_last_sig_cases()` que indica que se debe realizar la prueba Chi<sup>2</sup> a la relación. Esta línea provoca que en la tabla surja una nueva fila sobre el `#Total` con el texto `#Chi-squared p-value` que indica que se realiza la prueba al 5% (0,05). Si el resultado es el rechazo de la hipótesis nula de independencia se muestra un `<0,05 (warn.)`, pero si no se puede rechazar la hipótesis nula de independencia sale sólo `(warn.)` En la tabla no se publica el resultado de la prueba, pero podemos hacerlo siguiendo el formato estándar.

```{r fig.cap='Prueba Chi<sup>2</sup>', out.width='80%', fig.asp=.75, fig.align='center', echo=TRUE, warning=FALSE}
table(data$P2, data$P31)
chisq.test(table(data$P2, data$P31))
table(data$P33, data$P31)
chisq.test(table(data$P33, data$P31))
```

Donde se puede observar que para la primera relación, no se puede rechazar la hipótesis de independencia pues el valor de significación es p-value > 0,05 (0.2015); para la segunda relación, sí podemos rechazar la hipótesis nula de independencia, puesto que p-value < 0,05 (por tanto, existe dependencia).

### De una celda de una tabla

Particularmente de interés es la prueba Chi<sup>2</sup> de celda. A diferencia de la anterior, en este caso se realiza la prueba para cada celda de la tabla en particular. La lógica de la misma sería comparar un valor de la tabla (una celda), con el resto de su fila, el resto de su columna, y el resto de la muestra. De este forma, indicamos que valores son significativos en la tabla, aquellos que cabría contemplar con un interés especial.

Para obtener la tabla y la subsiguiente prueba se utilizará una nueva función denominada `tab_last_sig_cell_chisq()` sobre la misma estructura ya conocida de tabla. Nótese que en este caso, para la prueba se requiere utilizar los porcentajes en lugar de los casos, para que el cálculo sea el oportuno. Chi<sup>2</sup> es una prueba muy sensible al tamaño de la muestra.


```{r fig.cap='Prueba Chi<sup>2</sup> de celda', out.width='80%', fig.asp=.75, fig.align='center', echo=TRUE, warning=FALSE}
as.datatable_widget(data %>% 
    tab_cols(total(), '|'=unvr(P31)) %>% 
    tab_cells('|'=unvr(P2)) %>% 
    tab_stat_cpct() %>% 
    tab_last_sig_cell_chisq() %>%
    tab_pivot())

as.datatable_widget(data %>% 
    tab_cols(total(), '|'=unvr(P31)) %>% 
    tab_cells('|'=unvr(P33)) %>% 
    tab_stat_cpct() %>% 
    tab_last_sig_cell_chisq() %>%
    tab_pivot())
```
La salida es muy clara. Con los símbolos mayor y menor, se marcan aquellas celdas que son significativamente mayores (>) o menores (<) que lo esperado y por tanto son las que direccionan las relaciones de dependencia que en la tabla se producen. 


## Pruebas de diferencias

Un conjunto diferentes de pruebas son aquellas cuya hipótesis de partida se basa en determinar si existen diferencias entre los porcentajes (prueba z) o las medias (prueba t) de dos grupos independientes en la muestra extraídos de la misma población. Desarrollamos ambas pruebas en las líneas siguientes.

### Porcentajes (prueba z)

Asumiendo las hipótesis necesarias para poder trabajar con estadística paramétrica (normalidad, homoscedasticidad, linealidad y en algunos casos independencia), la función `tab_last_sig_cpct` realiza z-test entre columnas de porcentajes derivadas de la aplicación de `tab_stat_cpct`. Los resultados son calculados con la misma fórmula que con la función base de R [`prop.test`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/prop.test) y sin la corrección de continuidad.

Obsérvese la diferencia de concepto; mientras que la prueba Chi<sup>2</sup> de celda realiza la prueba comparando con el marginal total, la `prueba z` realiza esa comparación entre los grupos formados por las columnas, a los que se suele llamar perfiles. De esta forma considera la independencia de los grupos muestrales entre sí. 

Para utilizar esta funcionalidad el script sería el siguiente:

```{r  fig.cap='Prueba Z en tabla', out.width='80%', fig.asp=.75, fig.align='center', echo=TRUE, warning=FALSE}
as.datatable_widget(data %>% 
    tab_cols(total(), 'SEXO'=unvr(P31)) %>% 
    tab_cells('|'=unvr(P2)) %>% 
    tab_stat_cpct() %>% 
    tab_last_sig_cpct() %>%
    tab_pivot())

as.datatable_widget(data %>% 
    tab_cols(total(), 'SEXO'=unvr(P31)) %>% 
    tab_cells('|'=unvr(P33)) %>% 
    tab_stat_cpct() %>% 
    tab_last_sig_cpct() %>%
    tab_pivot())
```
En nuestro caso, los resultados son muy semejantes a los vistos con Chi<sup>2</sup> de celda, porque la variable elegida para las columnas es dicotómica, es decir, con sólo dos opciones de respuesta, exhaustivas y mutuamente excluyentes. No sería así si la variable de columnas presentara más de 2 perfiles.

La lectura de esta prueba es la siguiente. El porcentaje de casos en en el grupo B (mujeres) de la tabla 1, es significativamente más elevado que el de hombres, determinándose esta diferencia con una significación del 5%. En el caso de la tabla 2, el porcentaje de hombres solteros es significativamente diferente del porcentaje de mujeres solteras. Del mismo modo y a la inversa el porcentaje de mujeres viudas entrevistadas en la muestra es significativamente mayor que el de hombres.

Por tanto, creemos que queda claro el funcionamiento de la prueba. Se etiquetan las columnas y se muestra la letra de la columna con la que se presentan diferencias positivas junto al valor porcentual. La prueba se realiza para cada celda, pero siempre comparando con las celdas que tiene a su derecha o izquierda en la misma fila (no con el total).

### Medias (prueba t)

Al igual que en el apartado anterior el objetivo es determinar si existen o no diferencias entre los grupos que se están testando, teniendo como hipótesis nula que las medias de los grupos son iguales. En nuestro ejemplo, hemos tomado la de auto clasificación ideológica (recodificando las posiciones de 1 a 10, izquierda a derecha respectivamente) creando grupos de izquierda, centro y derecha. Sobre esta tabla que calcula las medias, se aplica el estadístico `tab_stat_mean_sd_n()`que contiene todos los datos requeridos para el cálculo del valor t y se le indica que requerimos el test con `tab_last_sig_means()`. Se asume que los grupos son independientes, que existe normalidad y que las varianzas de los grupos son iguales.

```{r fig.cap='Prueba t en tabla', out.width='80%', fig.asp=.75, fig.align='center', echo=TRUE, warning=FALSE}
as.datatable_widget(data %>% 
    tab_cols(total(), P29=recode(P29, 'Izquierda' = 1:4 ~1, 'Centro' = 5:6 ~2, 'Derecha' = 7:10 ~ 3, TRUE ~ NA)) %>% 
    tab_cells(P3=na_if(P3, gt(10))) %>% 
    tab_stat_mean_sd_n() %>% 
    tab_last_sig_means() %>%
    tab_pivot())
```

Se puede observar que la salida es igual a la de la prueba Z. Se rotulan las columnas con las letras A, B ... y las que sean necesarias, y posteriormente se muestra (por defecto) la letra de la columna con la que la media de la columna en la que se ubica la media presenta diferencias positivas (es mayor). Podemos por tanto observar, que en la población de la que se ha extraído la muestra, se puede afirmar que la media de satisfacción con el funcionamiento del sistema sanitario español es más alta en los individuos cuya auto clasificación ideológica es del grupo de derecha (C), que en la izquierda (A) y en el centro (B). No entramos a valorar si la distribución de grupos es la correcta o no, en cuanto al significado general. Se ha hecho una distribución acorde al significado de los números en sí mismos.

Existen ocasiones en las que esta prueba, se requiere publicar para un conjunto de ítems que forman parte de una misma batería. En estos casos, no es tan interesante publicar las desviaciones y las bases, por lo que podemos formular de esta forma el script.

```{r fig.cap='Prueba t con sólo medias', out.width='80%', fig.asp=.75, fig.align='center', echo=TRUE, warning=FALSE}
as.datatable_widget(data %>% 
    tab_cols(total(), P29=recode(P29, 'Izquierda' = 1:4 ~1, 'Centro' = 5:6 ~2, 'Derecha' = 7:10 ~ 3, TRUE ~ NA)) %>% 
    tab_cells(P901=na_if(P901, gt(10))) %>% 
    tab_stat_mean_sd_n() %>% 
    tab_last_sig_means(keep='means') %>%
    tab_cells(P902=na_if(P902, gt(10))) %>% 
    tab_stat_mean_sd_n() %>% 
    tab_last_sig_means(keep='means') %>%
    tab_cells(P903=na_if(P903, gt(10))) %>% 
    tab_stat_mean_sd_n() %>% 
    tab_last_sig_means(keep='means') %>%
    tab_cells(P904=na_if(P904, gt(10))) %>% 
    tab_stat_mean_sd_n() %>% 
    tab_last_sig_means(keep='means') %>%
    tab_cells(P905=na_if(P905, gt(10))) %>% 
    tab_stat_mean_sd_n() %>% 
    tab_last_sig_means(keep='means') %>%
    tab_cells(P906=na_if(P906, gt(10))) %>% 
    tab_stat_mean_sd_n() %>% 
    tab_last_sig_means(keep='means') %>%
    tab_cells(P907=na_if(P907, gt(10))) %>% 
    tab_stat_mean_sd_n() %>% 
    tab_last_sig_means(keep='means') %>%
    tab_pivot())
```
Se puede observar que la instrucción `keep='means'` lo que ha conseguido es eliminar la publicación de la desviación y la media del cuadro presentado. De este modo el resultado es más compacto y da una visión general de la batería de ítems

## Parámetros posibles en las pruebas de significación

De manera conjunta exponemos aquí diferentes parámetros que modifican el comportamiento por defecto de las cuatro pruebas anteriormente vistas. Algunos son de uso en todas ellas y otros específicos de alguna de las pruebas.

* `sig_level`, numérico; nivel de significación, por defecto es igual a 0.05.
* `min_base`, numérico; el test de significación se realizará si ambas columnas tienes bases mayores o iguales al valor determinado que por defecto es 2.
* `delta_cpct`, numérico; delta mínimo entre el porcentaje para el que marcamos diferencias significativas (en puntos porcentuales); de forma predeterminada, es igual a cero. Tenga en cuenta que, por ejemplo, para una diferencia mínima de 5 por ciento de puntos, delta_cpct debe ser igual a 5, no 0.05.
* `delta_means`, numérico; delta mínimo entre medias para las que marcamos diferencias significativas: por defecto es igual a cero.
* `correct`, lógico (TRUE o FALSE), indica si aplicar corrección de continuidad al calcular el estadístico Chi<sup>2</sup> de prueba para tablas de 2 por 2. Solo para `significance_cases` y `significance_cell_chisq`. Para más detalles ver [chisq.test](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/chisq.test). TRUE por defecto.
* `compare_type`  tipo de comparación por columnas. Por defecto, es subtabla (variable por variable). otras posibilidades son `"first_column"`, `"adjusted_first_column"` y `"previous_column"`; podemos realizar varios test simultáneamente.
* `bonferroni`  lógico; FALSE por defecto; uso del ajuste de Bonferroni por cada fila.
* `subtable_marks`, carácter; una de las siguientes opciones: `"greater"`, `"both"` or `"less"`; por defecto se marcan sólo valores cuya significación sea mayor (`"greater"`) que alguna otra columna. Para `significance_cell_chisq` por defecto es `"both"`. podemos modificar este comportamiento usando las otras alternativas.
* `inequality_sign`  logical. FALSE if subtable_marks is "less" or "greater". Should we show > or < before significance marks of subtable comparisons.
* `sig_labels` character vector labels for marking differences between columns of subtable.
* `sig_labels_previous_column`  a character vector with two elements. Labels for marking a difference with the previous column. First mark means ’lower’ (by default it is v) and the second means greater (^).
* `sig_labels_first_column`  a character vector with two elements. Labels for marking a difference with the first column of the table. First mark means ’lower’ (by default it is -) and the second means ’greater’ (+).
* `sig_labels_chisq`  a character vector with two labels for marking a difference with row margin of the table. First mark means ’lower’ (by default it is <) and the second means ’greater’ (>). Only for significance_cell_chisq.
* `keep`, carácter. Una o más de las siguientes `"percent"`, `"cases"`, `"means"`, `"bases"`, `"sd"` o `"none"`. Este argumento determina qué estadísticos permanecerán en la tabla después del marcado de significación.
* `row_margin`, carácter. Uno de los valores `"auto"` (predeterminado), `"sum_row"` o `"first_column"`. Si es `"auto"`, tratamos de encontrar la columna total en la subtabla por `total_column_marker`. Si la búsqueda falla, usamos la suma de cada fila como total de filas. Con la opción `"sum_row"` siempre sumamos cada fila para obtener margen. Tenga en cuenta que en este caso el resultado de las variables de respuesta múltiple en la cabecera puede ser incorrecta. Con la opción `"first_column"` usamos la tabla primera columna como margen de fila para todas las subtablas. En este caso, el resultado de las subtablas con bases incompletas puede ser incorrecto. Solo para `significance_cell_chisq`.
* `total_marker`, carácter. Total de fila marcado en la tabla. `" # "` por defecto.
* `total_row`, entero/carácter. En el caso de varios totales por subtabla, es un número o nombre de fila total para el cálculo de significación.
* `digits`, un número entero que indica cuántos dígitos después del separador decimal se mostrarán en la tabla final.
* `na_as_zero`, lógico; FALSE por defecto. ¿Deberíamos tratar a NA como cero casos?
* `var_equal`,  lógico; variable que indica si se deben tratar las dos varianzas como iguales. Para más detalles ver [t.test](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/t.test).
* `mode`, carácter; `"replace" (default)` o `"append"`. En el primer caso, el resultado anterior en la secuencia del cálculo de la tabla se reemplazará con el resultado de la prueba de significación. En el segundo caso, el resultado de la prueba de significación se agregará a la secuencia del cálculo de la tabla.
* `label`, carácter;  etiqueta para la estadística en tab_*. Ignorado si el modo es igual a `replace`.
* `total_column_marker`, carácter; marca para la columna de totales en las subtablas. "#" por defecto.
* `x`  table (class etable): result of cro_cpct with proportions and bases for significance_cpct, result of cro_mean_sd_n with means, standard deviations and valid N for significance_means, and result of cro_cases with counts and bases for significance_cases.
* `cases_matrix`, matriz numérica con recuentos de tamaño filas*columnas.
* `row_base`, vector de números con las bases de fila.
* `col_base`, vector de números con las bases de columna.
* `total_base`, número con la base total.

### Algunos ejemplos de uso de los parámetros

Cambio del nivel de significación de la prueba y eliminación de las filas con las frecuencias, entre otros...

```{r fig.cap='Prueba Chi<sup>2</sup> con significación al 99%', out.width='80%', fig.asp=.75, fig.align='center', echo=TRUE, warning=FALSE}
as.datatable_widget(data %>% 
    tab_cols(total(), '|'=unvr(P31)) %>% 
    tab_cells('|'=unvr(P33)) %>% 
    tab_stat_cases() %>% 
    tab_last_sig_cases(sig_level = 0.01, correct = TRUE, keep='bases', mode='replace', label='***') %>%
    tab_pivot())
```

## Conclusión

Hasta aquí llegamos. Hemos presentado de forma muy breve y simplificada como podemos aprovechar toda la potencia de `expss` en nuestros scripts. Lo importante es practicar y practicar. No dejes de acudir a las viñetas de ayuda de [Gregory Demin](http://gdemin.github.io/expss/) acerca de como usar el paquete y como generar nuevas tablas. Nosotros tan sólo hemos sentado las bases. Combinando las tablas con lenguaje R se puede llegar a conseguir casi todo.

* [manual PDF de EXPSS](https://cran.r-project.org/web/packages/expss/expss.pdf)
* [material de ayuda, ejemplos](https://cran.r-project.org/web/packages/expss/vignettes/tables-with-labels.html)
* [uso de etiquetas en R](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html)
