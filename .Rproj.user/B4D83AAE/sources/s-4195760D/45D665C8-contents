# Otras utilidades y tablas especiales {#tse06}

## Plan de códigos {#plan}

De forma muy sencilla, podemos obtener de nuestro fichero de datos lo que se denomina el _codeplan_ [@mohler2008survey] o libro de códigos. `expss` tiene una orden directa para ello. Este libro de códigos nos permitirá de forma muy sencilla conocer de primera mano, con mayor o menor precisión, de forma exploratoria el contenido de nuestro banco de datos o en definitva la codificación que se ha utilizado.

Cuatro elementos de información son los más importantes en la creación de un plan de códigos [@mohler2008survey]:

* Conocer los textos de etiquetado de las variables en el cuestionario (ítem, escala de respuesta,instrucción del entrevistador, etc.) y conocer su caracterización en el archivo de datos a partir de su posición, longitud, nombre de campo,etc.;
* Propiedades del campo de datos numéricos (ancho, decimales, alfa (carácter),o numérico);
* Definición de los valores de escala de respuesta, filtros, rechazos, no sabe, no contesta...;
* Conocimiento de las variables de clasificación

La siguiente sintaxis nos permite alcanzar este objetivo con poco esfuerzo y como punto de partida para el siguiente punto de recodificación. 

```{r codeplan1}
suppressMessages(setwd("~/R/r-data/00.tables")) #esta es la carpeta donde almacené el archivo (en una subcarpeta llamada data)
suppressMessages(library(expss)) #cargamos el paquete
suppressMessages(data <- read_spss("data/3192.sav")) #cargamos los datos
as.datatable_widget(info(data))
```

Los modificadores de la función `info`, permiten ir desde el listado más completo (el mostrado) hasta la supresión de elementos como las frecuencias o los descriptivos básicos, al tiempo que agilizan su cálculo.

```{r codeplan2}
as.datatable_widget(info(data, stats = FALSE, frequencies = FALSE))
```

Conociendo el libro de códigos, accedamos al apartado de recodificación. Si quieres más información sobre el comendo `info`usa la función `help(topic = info)` o también `?expss:info`.

## Recodificar {#recode}

Aunque ya en la sección anterior anterior hicimos una breve incursión en el uso de la recodificación, el paquete `expss` dispone de una serie de opciones muy interesantes acerca de este funcionalidad que usamos mucho en nuestro trabajo diario.

La función `recode` cambia la codificación de una variable en el contexto que se utiliza. Puede ser usada también para reorganizar o consolidar los valores de una variable existente en función de las condiciones. El diseño de esta función está inspirada en la utilidad `RECODE` de SPSS. El usuario facilita una secuencia de recodificaciones proporcionadas en forma de fórmulas. 

Por ejemplo, `1:2 ~ 1` significa que todos los valores 1 y 2 se reemplazarán con 1. Cada valor se recodificará solo una vez, es decir, sea realiza una única 'pasada' por el registro empezando por el 1 y acabando por el N. 

Dos formas de uso:

* Si `recode()` se usa como funcionalidad diferenciada, en este proceso de asignación aquellos valores que no cumplan ninguna condición permanecen sin cambios. * Si `recode()`se usa dentro de una tabla, los valores de recodificación (...) que no cumplen ninguna condición serán reemplazados por NA. 

Se pueden usar valores o condiciones lógicas más sofisticadas y funciones como condición. Hay varias funciones especiales para su uso como criterios; para más detalles, consulte los criterios \@ref(criteria) en su sección \@ref(tse08). 

El uso común se parece a este: `recode(x, 1:2 ~ -1, 3 ~ 0, 4:5 ~ 1, 99 ~ NA)`. Se puede observar que a los valores originales 1 y 2 se les imputa un -1, al 3 un 0, y a los valores 4 y 5 se les imputa un 1, el 99 se convierte en NA (valor perdido).

Para más información, ver detalles y ejemplos a continuación. Te dejamos los ejemplos del autor que ilustran muy bien las posibilidades de esta funcionalidad. Se reproducen los ejemplos de recodificación extraídos del manual de SPSS. Se utilizan datos ficticios generados en línea.

```{r fig.cap='Ejemplos de recodificación 1', out.width='80%', fig.asp=.75, fig.align='center', echo=TRUE}
# RECODE V1 TO V3 (0=1) (1=0) (2, 3=-1) (9=9) (ELSE=SYSMIS)
v1  = c(0, 1, 2, 3, 9, 10) # se crea la variable
v1
recode(v1) = c(0 ~ 1, 1 ~ 0, 2:3 ~ -1, 9 ~ 9, TRUE ~ NA)
v1

# RECODE QVAR(1 THRU 5=1)(6 THRU 10=2)(11 THRU HI=3)(ELSE=0).
qvar = c(1:20, 97, NA, NA)
recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, 11 %thru% hi ~ 3, TRUE ~ 0)

# the same result
recode(qvar, 1 %thru% 5 ~ 1, 6 %thru% 10 ~ 2, ge(11) ~ 3, TRUE ~ 0)

# RECODE STRNGVAR ("A", "B", "C"="A")("D", "E", "F"="B")(ELSE=" "). 
strngvar = LETTERS
recode(strngvar, c("A", "B", "C") ~ "A", c("D", "E", "F") ~ "B", TRUE ~ " ")

# recode in place. Note that we recode only first six letters
recode(strngvar) = c(c("A", "B", "C") ~ "A", c("D", "E", "F") ~ "B")
strngvar

# RECODE AGE (MISSING=9) (18 THRU HI=1) (0 THRU 18=0) INTO VOTER. 
age = c(NA, 2:40, NA)
voter = recode(age, NA ~ 9, 18 %thru% hi ~ 1, 0 %thru% 18 ~ 0)
voter

# the same result with "%into%"
recode(age, NA ~ 9, 18 %thru% hi ~ 1, 0 %thru% 18 ~ 0) %into% voter2
voter2

# recode with adding labels
voter = recode(age, "Refuse to answer" = NA ~ 9,"Vote" = 18 %thru% hi ~ 1, "Don't vote" = 0 %thru% 18 ~ 0)
voter

# recoding with labels
ol = c(1:7, 99)
var_lab(ol) = "Liking" #texto extra
val_lab(ol)  = c("Disgusting" =1, "Very Poor"=2, "Poor"=3, "So-so"=4, "Good"=5, "Very good"=6, "Excellent"=7, "Hard to say"=99) #etiquetas códigos
recode(ol, 1:3 ~ 1, 5:7 ~ 7, TRUE ~ copy, with_labels = TRUE)

# "rec" is a shortcut for recoding with labels. Same result: 
rec(ol, 1:3 ~ 1, 5:7 ~ 7, TRUE ~ copy)

# another method of combining labels
recode(ol, 1:3 ~ 1, 5:7 ~ 7, TRUE ~ copy, with_labels = TRUE, new_label = "range")

# example with from/to notation

# RECODE QVAR(1 THRU 5=1)(6 THRU 10=2)(11 THRU HI=3)(ELSE=0).
list_from = list(1 %thru% 5, 6 %thru% 10, ge(11), TRUE)
list_to = list(1, 2, 3, 0)
recode(qvar, from_to(list_from, list_to))


list_from = list(NA, 18 %thru% hi, 0 %thru% 18)
list_to = list("Refuse to answer" = 9, "Vote" = 1, "Don't vote" = 0)
voter = recode(age, from_to(list_from, list_to))
voter

# "ifs" examples
a = 1:5
b = 5:1
a
b
ifs(b>3 ~ 1)                       # c(1, 1, NA, NA, NA)
ifs(b>3 ~ 1, TRUE ~ 3)             # c(1, 1, 3, 3, 3)
ifs(b>3 ~ 1, a>4 ~ 7, TRUE ~ 3)    # c(1, 1, 3, 3, 7)
ifs(b>3 ~ a, TRUE ~ 42)            # c(1, 2, 42, 42, 42)

```

El `recode()`puede ser utilizado como funcionalidad separada y con asignación o dentro de la definición de una variable. Por ejemplo:

```{r fig.cap="Ejemplos de recodificación 2", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
v1 <- c(1,2,3,2,1,2,3,4,5,6,5,4,3,2,1)
v2 <- v1
v1
v2
v1 <- recode(v1, 1:5 ~ 1, 6:10 ~ 2)
mean(v1,na.rm=TRUE)
mean(recode(v2, 1:5 ~ 1, 6:10 ~ 2), na.rm=TRUE)
v1
v2
```
Nótese que la diferencia estriba en que mientras que al finalizar el proceso `v1` tiene solo valores 1 y 2 recodificados, `v2` (copia de v1) mantiene los valores originales.

## Cuadros

En ocasiones es interesante reproducir algún tipo de cuadro que se ha presentado al entrevistado (baterías de ítems, cuadros, rejillas o grids, grillas o tablas de ítems, son sinónimos). Por ejemplo la pregunta `P9` del cuestionario nos presenta un cuadro en el que hay hasta 7 ítems valorados de 1 a 10, con los valores 98 y 99 como `NS` y `NC` respectivamente. Así que vamos a procesar esas tablas como cuadros.

Nuestro script es el siguiente ...

```{r fig.cap="Cuadros de baterías", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
as.datatable_widget(data %>% 
    tab_cells(P901 %to% P907) %>% 
    tab_stat_cpct() %>%
    tab_pivot())
```

Esta sería la salida lógica que damos a la tabla. Sin embargo utilizando algunos pequeños trucos, podemos presentarlo así.

```{r fig.cap="Cuadros de baterías modificado", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
val_lab(data$P901) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
val_lab(data$P902) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
val_lab(data$P903) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
val_lab(data$P904) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
val_lab(data$P905) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
val_lab(data$P906) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
val_lab(data$P907) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)

as.datatable_widget(data %>% 
    tab_cells("|"=unvr(P901)) %>% 
    tab_stat_cpct(label=var_lab(P901), total_row_position="none") %>%
    tab_stat_mean_sd_n(label="P901") %>%
    tab_cells("|"=unvr(P902)) %>% 
    tab_stat_cpct(label=var_lab(P902), total_row_position="none") %>%
    tab_stat_mean_sd_n(label="P901") %>%
    tab_cells("|"=unvr(P903)) %>% 
    tab_stat_cpct(label=var_lab(P903), total_row_position="none") %>%
    tab_stat_mean_sd_n(label="P901") %>%
    tab_cells("|"=unvr(P904)) %>% 
    tab_stat_cpct(label=var_lab(P904), total_row_position="none") %>%
    tab_stat_mean_sd_n(label="P901") %>%
    tab_cells("|"=unvr(P905)) %>% 
    tab_stat_cpct(label=var_lab(P905), total_row_position="none") %>%
    tab_stat_mean_sd_n() %>%
    tab_cells("|"=unvr(P906)) %>% 
    tab_stat_cpct(label=var_lab(P906), total_row_position="none") %>%
    tab_stat_mean_sd_n() %>%
    tab_cells("|"=unvr(P907)) %>% 
    tab_stat_cpct(label=var_lab(P907), total_row_position="none") %>%
    tab_stat_mean_sd_n() %>%
    tab_pivot(stat_position="inside_columns") %>% 
    t())
```

¿Qué hemos hecho?, hemos limpiado el texto de la variable utilizando la función `"|"=unvr()` y ese mismo texto extra de la variable `var_lab()` se lo hemos asignado al estadístico con `label`. De esta forma el resultado es el que ves. Desafortunadamente, hay un pequeño bug del que está informado el autor, de no poder situar la media y/o la desviación típica en la misma fila. Para hacerlo hay que unir dos tablas. Como esperamos esté resuelto en breve, no damos la solución por no complicar más la salida.

## Ponderación

Otro de los aspectos fundamentales en la investigación de mercados es la ponderación. Lo primero que debemos entender es el propio concepto de ponderación. En definitiva, es hacer que cada registro (% de casos o casos o estadísticos) en lugar de contar como un caso (frecuencia 1), cuente como n casos, siendo n el valor de otro campo (indicado en `weight()` -peso-) del marco de datos. Este peso ha sido obtenido por un procedimiento llamado equilibraje o _raking_ [@biemer2008weighting].

Aquí muestro la tabla, sin ponderar ...

```{r fig.cap="Uso de ponderación", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
as.datatable_widget(data %>% 
    tab_cols(total(),P3 ) %>%
    tab_cells(mdset(P21A01 %to% P21A03)) %>% 
    tab_stat_cpct() %>% 
    tab_pivot())
```

El estudio del CIS que estamos trabajando tiene una variable denominada PESO que contiene el coeficiente de ponderación para adaptarse a la población real española. Aquí dejamos la anterior tabla, pero ponderada. Véase las diferencias entre todos los valores.

```{r fig.cap="Uso de ponderación con multi respuesta", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
as.datatable_widget(data %>% 
    tab_cols(total(),P3 ) %>%
    tab_weight(PESO) %>%
    tab_cells(mdset(P21A01 %to% P21A03)) %>% 
    tab_stat_cpct() %>% 
    tab_pivot())
```

Aunque este manual se refiere únicamente a tablas, es bastante habitual obtener en toda ponderación la denominada eficiencia de la misma. Este análisis lo realizamos utilizando R como calculadora. Podemos hacer una análisis de la variable PESO y de su eficiencia.

```{r fig.cap="Cálculo de la eficiencia del peso", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
mean.peso <- mean(data$PESO, na.rm=TRUE)
sd.peso <- sd(data$PESO, na.rm=TRUE)
ratio <- sd.peso/mean.peso
eficiencia <- (1/(1+(ratio^2)))*100
eficiencia <- round(eficiencia,2)
```

Puede observarse como la eficiencia de la ponderación es del `r eficiencia` %. 

## Subtotales y NETS

Otra de las funcionalidades básicas en nuestro trabajo de análisis es el uso de subtotales y/o netos. El objetivo de ambas funciones es reagrupar los códigos de una determinada variable, permitiendo observar acumulados de frecuencia. El paquete `expss` hace una diferenciación entre ambos que mostraremos seguidamente. 

### Subtotales

El uso de **`tab_subtotal_rows`** o **`tab_subtotal_cols`** o **`tab_subtotal_cells`** añade subtotales a un conjunto de categorías de la variable sobre la que se aplique. Si se introduce un texto se utilizará el mismo, pero si no se añade la palabra TOTAL. Debes tener en cuenta que si las agrupaciones de categorías que realizas se solapan, también se solaparán los recuentos en el cálculo de subtotales. Estos subtotales pueden ser aplicados a las variables del banco de datos.

```{r fig.cap="Uso de subtotales 1", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
val_lab(data$P901) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
as.datatable_widget(data %>% 
    tab_cols(total(), P31) %>% 
    tab_cells(P901) %>% 
    tab_subtotal_cells("NO SATISFACTORIO"= 1:5, 6:8,  "SATISFACTORIO"=9:10) %>% 
    tab_stat_cpct() %>% 
    tab_pivot())
```

Nótese que en el ejemplo han sido utilizados textos en solo dos de los tres subtotales que se han calculado. Si no se introduce texto, es cuando se usa la palabra TOTAL. Nótese también que por defecto los subtotales aparecen detrás del último valor del grupo, detrás del 5, detrás del 8 y detrás del 10. Existe la posibilidad de determinar mediante una instrucción como deben aparecer. El modificador o parámetro `position` con posibles valores `"below"`, `"above"`, `"top"` o `"bottom"` indicarán el lugar donde se deben imprimir. Del mismo modo, se puede forzar a que sea el propio sistema quien determine las etiquetas del subtotal generado. Así el modificador `prefix` puede determinar un prefijo para todas las etiquetas siendo `TOTAL` el valor por defecto, y también el modificador `new_label`que permite indicar si la etiqueta se construye usando las etiquetas originales respondiendo a `all`que la usa todas, `range` la primera y la última, `first` la primera del grupo y `last` la última del grupo. 

Con todo ello, podríamos modificar nuestro ejemplo a:

```{r fig.cap="Uso de subtotales 2", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
val_lab(data$P901) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
as.datatable_widget(data %>% 
    tab_cols(total(), P31) %>% 
    tab_cells(P901) %>% 
    tab_subtotal_cells(1:5, 6:8, 9:10, position = "bottom", prefix ="SUBT", new_label="range") %>% 
    tab_stat_cpct() %>% 
    tab_pivot())
```

### NETS

El uso de **`tab_net_rows()`** o **`tab_net_cols()`** o **`tab_net_cells()`** sustituye por netos (subtotales) a un conjunto de categorías de la variable sobre la que se aplique. Si se introduce un texto se utilizará el mismo, pero si no es así, se añade la palabra TOTAL. 

Debes tener en cuenta que si las agrupaciones de categorías que realizas se solapan, también se solaparán los recuentos en el cálculo de netos. Estos netos pueden ser aplicados a las variables del banco de datos. La terminología de NET suele ser muy aplicada en las variables de tipo múltiple, para agrupar conceptos similares. En nuestro ejemplo por mantener la coherencia con el uso de `subtotal` lo aplicaremos sin embargo con una variable numérica de valoración.

```{r fig.cap="Uso de nets 1", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
val_lab(data$P901) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
as.datatable_widget(data %>% 
    tab_cols(total(), P31) %>% 
    tab_cells(P901) %>% 
    tab_net_cells("NO SATISFACTORIO"= 1:5, 6:8,  "SATISFACTORIO"=9:10) %>% 
    tab_stat_cpct() %>% 
    tab_pivot())
```

Nótese que en el ejemplo han sido utilizados textos en solo dos de los tres `nets` que se han calculado. Si no se introduce texto, es cuando se usa la palabra TOTAL. Nótese también que por defecto los subtotales aparecen detrás del último valor del grupo, detrás del 5, detrás del 8 y detrás del 10. Existe la posibilidad de determinar mediante una instrucción como deben aparecer. El modificador o parámetro `position` con posibles valores `"below", "above", "top" o "bottom"` indicarán el lugar donde se deben imprimir. 

Del mismo modo, se puede forzar a que sea el propio sistema quien determine las etiquetas del subtotal generado. Así el modificador `prefix` puede determinar un prefijo para todas las etiquetas siendo `TOTAL` el valor por defecto, y también el modificador `new_label`que permite indicar si la etiqueta se construye usando las etiquetas originales respondiendo a `all`que la usa todas, `range` la primera y la última, `first` la primera del grupo y `last` la última del grupo. Podríamos modificar nuestro ejemplo a:

```{r fig.cap="Uso de nets 2", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
val_lab(data$P901) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
as.datatable_widget(data %>% 
    tab_cols(total(), P31) %>% 
    tab_cells(P901) %>% 
    tab_net_cells(1:5, 6:8, 9:10, position = "top", prefix ="NET", new_label="range") %>% 
    tab_stat_cpct() %>% 
    tab_pivot())
```

Puedes preguntarte el porqué del `position` si en un NET realmente se eliminan los códigos originales, pero esto no tiene por qué ser así. Tanto el `subtotal` como el `net` tienen la posibilidad de variar este hecho utilizando el modificar `add` con valores TRUE o FALSE que mantendría o no los códigos originales. No obstante, en nuestro ejmplo como hay valores no agrupados (NS y NC) aquí la posición sí es relevante.

## _Top_ y _Bottom_

Por último otra utilidad no menos importante que las anterior y no menos utilizada. El cálculo del _top_ y el _bottom_ de una escala. Para ello, vamos a basarnos en  algo que ya hemos visto en las tablas anteriores, la recodificación y el cómo reutilizamos la posibilidad de las variables múltiples.

Planteemos una situación en la que deseamos que la variable P901 se muestre de forma segmentada y conjuntamente cada uno de sus valores. Llamamos TOP a la agrupación en una columna o fila de tabla de aquellas categorías con las valoraciones más altas (por ejemplo 9 y 10) y BOTTOM a las más bajas (por ejemplo 1,2,3,4,5 y 6 o 1:6 como sabemos). Queremos que en la tabla se muestre ambas categorías. ¿Como la hacemos? Este es script.

```{r fig.cap="Uso de top y bottom", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
val_lab(data$P901) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
as.datatable_widget(data %>% 
    tab_cols(total(), P31) %>% 
    tab_cells(P901) %>% 
    tab_subtotal_cells("Bottom"= 1:6, "Top"=9:10) %>% 
    tab_stat_cpct() %>% 
    tab_pivot())
```

Controlando más algunos aspectos de la publicación de la tabla ...

```{r fig.cap="Uso de top y bottom arriba", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
val_lab(data$P901) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
as.datatable_widget(data %>% 
    tab_cols(total(), P31) %>% 
    tab_cells(P901) %>% 
    tab_subtotal_cells("Bottom"= 1:6, "Top"=9:10, position ="bottom") %>% 
    tab_stat_cpct(total_row_position="below") %>% 
    tab_cells(na_if(P901, gt(10))) %>% 
    tab_stat_mean() %>%
    tab_pivot())
```

Con subtotales abajo...

```{r fig.cap="Uso de top y bottom abajo", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
val_lab(data$P901) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
as.datatable_widget(data %>% 
    tab_cols(total(), P31) %>% 
    tab_cells(P901) %>% 
    tab_subtotal_cells("Bottom"= 1:6, "Top"=9:10, position ="below") %>% 
    tab_stat_cpct(total_row_position="below") %>% 
    tab_cells(na_if(P901, gt(10))) %>% 
    tab_stat_mean() %>%
    tab_pivot())
```

O también ...

```{r fig.cap="Uso de top y bottom sin los valores agrupados", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
val_lab(data$P901) <- c("1"=1, "2"=2, "3"=3, "4"=4, "5"=5, "6"=6, "7"=7, "8"=8, "9"=9, "10"=10, "N.S."=98, "N.C."=99)
as.datatable_widget(data %>% 
    tab_cols(total(), P31) %>% 
    tab_cells(P901) %>% 
    tab_net_cells("Top"=9:10, "Bottom" = 1:6) %>% 
    tab_stat_cpct(total_row_position="below") %>% 
    tab_cells(na_if(P901, gt(10))) %>% 
    tab_stat_mean() %>%
    tab_pivot())
```

Así pues en esta última tabla, hemos combinado algunas de las funcionalidades especiales y avanzadas de `expss` de forma conjunta y trabajando en la misma dirección.

### Gráficos base

Dejamos además aquí esta `pildora adictiva`. ¿Un gráfico? Repetimos la tabla pero la guardamos en una objeto llamada `tab`. Limpiamos además aquello que no nos interesa.

```{r fig.cap="Uso de gráfico highcharter 1", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
tab <- data %>% 
    tab_cols("|"=unvr(P31)) %>% 
    tab_cells("|"=unvr(P901)) %>% 
    tab_net_cells("Detractores" = 1:6, "Neutrales" = 7:8, "Promotores" = 9:10) %>% 
    tab_stat_cpct(total_row_position="none") %>% 
    tab_pivot()
tab <- as.data.frame(tab)
tab
```

Fíjate como hemos limpiado la tabla. Hemos usado un recurso que para gráficos será muy válido, el uso de `unvr()` que elimina del uso de la variable los textos extra. Del mismo modo con el `"|"=` hemos anulado cualquier tipo de texto suplementario que se pudiera añadir. Cuando hacemos una tabla y la guardamos, es un objeto `etable` que ya describimos anteriormente. Como la mayoría de los paquetes gráficos usan `_dataframe_`, lo transformamos a eso.

Una vez hecho esto, hacemos el gráfico. Podemos elegir diferentes sistemas de gráficos, pero los más habituales e interactivos son `highcharter`(paquete escrito sobre Highcharts) y/o `plotly`. Como paquete estático, `ggplot` sería la mejor solución.

```{r fig.cap="Uso de gráfico highcharter 2", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
suppressMessages(library(highcharter, quietly=TRUE))
highchart() %>%
    hc_xAxis(categories=tab$row_labels) %>% 
    hc_add_series(data=tab, type="column", hcaes(x=row_labels, y= Hombre), name="hombre") %>% 
    hc_add_series(data=tab, type="column", hcaes(x=row_labels, y= Mujer), name="mujer")
```

Alternativamente, si queremos utilizar el paquete `plotly` ...

```{r fig.cap="Uso de gráfico con plotly", out.width="80%", fig.asp=.75, fig.align="center", echo=TRUE}
Grupo <- factor(tab$row_labels, levels=tab$row_labels)
plot_ly(tab, x = ~Grupo, y = ~Hombre, type = "bar", name = "Hombre") %>% 
    add_trace(y = ~Mujer, name = "Mujer") %>% 
    layout(yaxis = list(title = "frecuencia"))
```
